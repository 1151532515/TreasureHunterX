{"version":3,"sources":["../../../../assets/scripts/assets/scripts/BasePlayer.js"],"names":["module","export","cc","Class","extends","Component","properties","animComp","type","Animation","default","baseSpeed","Float","speed","lastMovedAt","eps","magicLeanLowerBound","magicLeanUpperBound","start","self","contactedControlledPlayers","contactedNPCPlayers","coveringShelterZReducers","computedNewDifferentPosLocalToParentWithinCurrentFrame","actionMangerSingleton","ActionManager","scheduledDirection","dx","dy","activeDirection","onLoad","clips","canvasNode","mapNode","parent","contactedBarriers","joystickInputControllerScriptIns","getComponent","ctrl","node","play","scheduleNewDirection","newScheduledDirection","forceAnimSwitch","clipKey","toString","attacked","attackedClips","clip","console","warn","_addCoveringShelterZReducer","comp","coveringShelterZReducer","_id","push","_removeCoveringShelterZReducer","filter","_addContactedBarrier","collider","log","contactedBarrier","_removeContactedBarrier","_addContactedControlledPlayers","aComp","uuid","_removeContactedControlledPlayer","_addContactedNPCPlayers","_removeContactedNPCPlayer","_canMoveBy","vecToMoveBy","position","add","tileCollisionManager","isOutOfMapNode","currentSelfColliderCircle","CircleCollider","nextSelfColliderCircle","length","mutatedVecToMoveBy","mul","offset","radius","contactedBarrierPolygonLocalToParentWithinCurrentFrame","points","p","Intersection","pointInPolygon","polygonCircle","firstContactedEdge","associatedBarrier","res","_calculateTangentialMovementAttrs","contactedEdge","sDir","currentSelfColliderCircleCentrePos","currentSelfColliderCircleRadius","contactedEdgeCandidateList","skinDepthThreshold","i","stPoint","edPoint","tmpVSt","sub","tmpVEd","crossProdScalar","cross","dis","pointLineDistance","st","ed","contactedEdgeDir","largestInnerProdAbs","Number","MIN_VALUE","sDirMag","Math","sqrt","contactedEdgeCandidate","tmp","contactedEdgeDirCandidate","x","y","contactedEdgeDirCandidateMag","innerDotProd","innerDotProdThresholdMag","abs","_calculateVecToMoveByWithChosenDir","elapsedTime","v2","distanceToMove","denominator","unitProjDx","unitProjDy","_calculateVecToMoveBy","update","dt","lateUpdate","newScheduledDirectionInLocalCoordinate","discretizeDirection","now","Date","getTime","onCollisionEnter","other","playerScriptIns","name","showProfileTrigger","setLocalZOrder","onCollisionStay","onCollisionExit","hideProfileTrigger","_generateRandomDirection","ALL_DISCRETE_DIRECTIONS_CLOCKWISE","floor","random","_generateRandomDirectionExcluding","toExcludeDx","toExcludeDy","randomDirectionList","exactIdx","ii","updateSpeed","proposedSpeed","startFrozenDisplay","stopFrozenDisplay"],"mappings":"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","file":"BasePlayer.js","sourceRoot":"../../../../assets/scripts","sourcesContent":["module.export = cc.Class({\n  extends: cc.Component,\n\n  properties: {\n    animComp: {\n      type: cc.Animation,\n      default: null,\n    },\n    baseSpeed: {\n      type: cc.Float,\n      default: 300,\n    },\n    speed: {\n      type: cc.Float,\n      default: 300\n    },\n    lastMovedAt: {\n      type: cc.Float,\n      default: 0 // In \"GMT milliseconds\"\n    },\n    eps: {\n      default: 0.10,\n      type: cc.Float\n    },\n    magicLeanLowerBound: {\n      default: 0.414, // Tangent of (PI/8).\n      type: cc.Float\n    },\n    magicLeanUpperBound: {\n      default: 2.414, // Tangent of (3*PI/8).\n      type: cc.Float\n    },\n  },\n\n  // LIFE-CYCLE CALLBACKS:\n  start() {\n    const self = this;\n    self.contactedControlledPlayers = [];\n    self.contactedNPCPlayers = [];\n    self.coveringShelterZReducers = [];\n\n    self.computedNewDifferentPosLocalToParentWithinCurrentFrame = null;\n    self.actionMangerSingleton = new cc.ActionManager();\n    self.scheduledDirection = {\n      dx: 0.0,\n      dy: 0.0\n    };\n\n    self.activeDirection = {\n      dx: 0.0,\n      dy: 0.0\n    };\n  },\n\n  onLoad() {\n    const self = this;\n    self.clips = {\n      '01': 'Top',\n      '0-1': 'Bottom',\n      '-20': 'Left',\n      '20': 'Right',\n      '-21': 'TopLeft',\n      '21': 'TopRight',\n      '-2-1': 'BottomLeft',\n      '2-1': 'BottomRight'\n    };\n    const canvasNode = self.mapNode.parent;\n    self.contactedBarriers = [];\n    const joystickInputControllerScriptIns = canvasNode.getComponent(\"TouchEventsManager\");\n    self.ctrl = joystickInputControllerScriptIns;\n    self.animComp = self.node.getComponent(cc.Animation);\n    self.animComp.play();\n  },\n\n  scheduleNewDirection(newScheduledDirection, forceAnimSwitch) {\n    if (!newScheduledDirection) {\n      return;\n    }\n    if (forceAnimSwitch || null == this.scheduledDirection || (newScheduledDirection.dx != this.scheduledDirection.dx || newScheduledDirection.dy != this.scheduledDirection.dy)) {\n      this.scheduledDirection = newScheduledDirection;\n      const clipKey = newScheduledDirection.dx.toString() + newScheduledDirection.dy.toString()\n      const clips = this.attacked ? this.attackedClips : this.clips; \n      let clip = clips[clipKey];\n      if (!clip) {\n        // Keep playing the current anim.\n        if (0 !== newScheduledDirection.dx || 0 !== newScheduledDirection.dy) {\n          console.warn('Clip for clipKey === ' + clipKey + ' is invalid: ' + clip + '.');\n        }\n      } else {\n        this.animComp.play(clip);\n      }\n    }\n  },\n\n  _addCoveringShelterZReducer(comp) {\n    const self = this;\n    for (let coveringShelterZReducer of self.coveringShelterZReducers) {\n      if (coveringShelterZReducer._id == comp._id) {\n        return false;\n      }\n    }\n    self.coveringShelterZReducers.push(comp);\n    return true;\n  },\n\n  _removeCoveringShelterZReducer(comp) {\n    const self = this;\n    self.coveringShelterZReducers = self.coveringShelterZReducers.filter((coveringShelterZReducer) => {\n      return coveringShelterZReducer._id != comp._id;\n    });\n    return true;\n  },\n\n  _addContactedBarrier(collider) {\n    const self = this;\n    if (!self.contactedBarriers) {\n      cc.log(\"self.contactedBarriers is null or undefined\" + self.contactedBarriers)\n    }\n    for (let contactedBarrier of self.contactedBarriers) {\n      if (contactedBarrier._id == collider._id) {\n        return false;\n      }\n    }\n    self.contactedBarriers.push(collider);\n    return true;\n  },\n\n  _removeContactedBarrier(collider) {\n    const self = this;\n    self.contactedBarriers = self.contactedBarriers.filter((contactedBarrier) => {\n      return contactedBarrier._id != collider._id;\n    });\n    return true;\n  },\n\n  _addContactedControlledPlayers(comp) {\n    const self = this;\n    for (let aComp of self.contactedControlledPlayers) {\n      if (aComp.uuid == comp.uuid) {\n        return false;\n      }\n    }\n    self.contactedControlledPlayers.push(comp);\n    return true;\n  },\n\n  _removeContactedControlledPlayer(comp) {\n    const self = this;\n    self.contactedControlledPlayers = self.contactedControlledPlayers.filter((aComp) => {\n      return aComp.uuid != comp.uuid;\n    });\n    return true;\n  },\n\n  _addContactedNPCPlayers(comp) {\n    const self = this;\n    for (let aComp of self.contactedNPCPlayers) {\n      if (aComp.uuid == comp.uuid) {\n        return false;\n      }\n    }\n    self.contactedNPCPlayers.push(comp);\n    return true;\n  },\n\n  _removeContactedNPCPlayer(comp) {\n    const self = this;\n    self.contactedNPCPlayers = self.contactedNPCPlayers.filter((aComp) => {\n      return aComp.uuid != comp.uuid;\n    });\n    return true;\n  },\n\n  _canMoveBy(vecToMoveBy) {\n    const self = this;\n    const computedNewDifferentPosLocalToParentWithinCurrentFrame = self.node.position.add(vecToMoveBy);\n    self.computedNewDifferentPosLocalToParentWithinCurrentFrame = computedNewDifferentPosLocalToParentWithinCurrentFrame;\n\n    if (tileCollisionManager.isOutOfMapNode(self.mapNode, computedNewDifferentPosLocalToParentWithinCurrentFrame)) {\n      return false;\n    }\n\n    const currentSelfColliderCircle = self.node.getComponent(cc.CircleCollider);\n    let nextSelfColliderCircle = null;\n    if (0 < self.contactedBarriers.length) {\n      /* To avoid unexpected buckling. */\n      const mutatedVecToMoveBy = vecToMoveBy.mul(5); // To help it escape the engaged `contactedBarriers`.\n      nextSelfColliderCircle = {\n        position: self.node.position.add(mutatedVecToMoveBy).add(currentSelfColliderCircle.offset),\n        radius: currentSelfColliderCircle.radius,\n      };\n    } else {\n      nextSelfColliderCircle = {\n        position: computedNewDifferentPosLocalToParentWithinCurrentFrame.add(currentSelfColliderCircle.offset),\n        radius: currentSelfColliderCircle.radius,\n      };\n    }\n\n    for (let contactedBarrier of self.contactedBarriers) {\n      let contactedBarrierPolygonLocalToParentWithinCurrentFrame = [];\n      for (let p of contactedBarrier.points) {\n        contactedBarrierPolygonLocalToParentWithinCurrentFrame.push(contactedBarrier.node.position.add(p));\n      }\n      if (cc.Intersection.pointInPolygon(nextSelfColliderCircle.position, contactedBarrierPolygonLocalToParentWithinCurrentFrame)) {\n        // Make sure that the player is \"leaving\" the PolygonCollider.\n        return false;  \n      }\n      if (cc.Intersection.polygonCircle(contactedBarrierPolygonLocalToParentWithinCurrentFrame, nextSelfColliderCircle)) {\n        if (null == self.firstContactedEdge) {\n          return false; \n        }\n        if (null != self.firstContactedEdge && self.firstContactedEdge.associatedBarrier != contactedBarrier) {\n          const res = self._calculateTangentialMovementAttrs(nextSelfColliderCircle, contactedBarrier);\n          if (null == res.contactedEdge) {\n            // Otherwise, the current movement is going to transit smoothly onto the next PolygonCollider.\n            return false; \n          }\n        }\n      }\n    }\n\n    return true;\n\n    /*\n     * In a subclass, use \n     * \n     * _canMoveBy(vecToMoveBy) {\n     *   BasePlayer.prototype._canMoveBy.call(this, vecToMoveBy);\n     *   // Customized codes.\n     * }\n     *\n     * Reference http://www.cocos2d-x.org/docs/creator/manual/en/scripting/reference/class.html#override\n     */\n  },\n\n  _calculateTangentialMovementAttrs(currentSelfColliderCircle, contactedBarrier) {\n    /*\n     * Theoretically when the `contactedBarrier` is a convex polygon and the `PlayerCollider` is a circle, there can be only 1 `contactedEdge` for each `contactedBarrier`. Except only for around the corner.\n     *\n     * We should avoid the possibility of players hitting the \"corners of convex polygons\" by map design wherever & whenever possible.\n     *\n     */\n    const self = this;\n    const sDir = self.activeDirection;\n    const currentSelfColliderCircleCentrePos = (currentSelfColliderCircle.position ? currentSelfColliderCircle.position : self.node.position.add(currentSelfColliderCircle.offset));\n    const currentSelfColliderCircleRadius = currentSelfColliderCircle.radius;\n    let contactedEdgeCandidateList = [];\n    let skinDepthThreshold = 0.45*currentSelfColliderCircleRadius;\n    for (let i = 0; i < contactedBarrier.points.length; ++i) {\n      const stPoint = contactedBarrier.points[i].add(contactedBarrier.offset).add(contactedBarrier.node.position);\n      const edPoint = (i == contactedBarrier.points.length - 1 ? contactedBarrier.points[0].add(contactedBarrier.offset).add(contactedBarrier.node.position) : contactedBarrier.points[1 + i].add(contactedBarrier.offset).add(contactedBarrier.node.position));\n      const tmpVSt = stPoint.sub(currentSelfColliderCircleCentrePos);\n      const tmpVEd = edPoint.sub(currentSelfColliderCircleCentrePos);\n      const crossProdScalar = tmpVSt.cross(tmpVEd);\n      if (0 < crossProdScalar) {\n        // If moving parallel along `st <-> ed`, the trajectory of `currentSelfColliderCircleCentrePos` will cut inside the polygon. \n        continue; \n      } \n      const dis = cc.Intersection.pointLineDistance(currentSelfColliderCircleCentrePos, stPoint, edPoint, true); \n      if (dis > currentSelfColliderCircleRadius) continue;\n      if (dis < skinDepthThreshold) continue;\n      contactedEdgeCandidateList.push({\n        st: stPoint, \n        ed: edPoint,\n        associatedBarrier: contactedBarrier,\n      });\n    }\n    let contactedEdge = null;\n    let contactedEdgeDir = null;\n    let largestInnerProdAbs = Number.MIN_VALUE;\n\n    if (0 < contactedEdgeCandidateList.length) {\n      const sDirMag = Math.sqrt(sDir.dx * sDir.dx + sDir.dy * sDir.dy);\n      for (let contactedEdgeCandidate of contactedEdgeCandidateList) {  \n        const tmp = contactedEdgeCandidate.ed.sub(contactedEdgeCandidate.st);\n        const contactedEdgeDirCandidate = {\n          dx: tmp.x,\n          dy: tmp.y,\n        };\n        const contactedEdgeDirCandidateMag = Math.sqrt(contactedEdgeDirCandidate.dx * contactedEdgeDirCandidate.dx + contactedEdgeDirCandidate.dy * contactedEdgeDirCandidate.dy);\n        const innerDotProd = (sDir.dx * contactedEdgeDirCandidate.dx + sDir.dy * contactedEdgeDirCandidate.dy)/(sDirMag * contactedEdgeDirCandidateMag); \n        const innerDotProdThresholdMag = 0.7;\n        if ((0 > innerDotProd && innerDotProd > -innerDotProdThresholdMag) || (0 < innerDotProd && innerDotProd < innerDotProdThresholdMag)) {\n          // Intentionally left blank, in this case the player is trying to escape from the `contactedEdge`.    \n          continue;\n        } else if (innerDotProd > 0) {\n          const abs = Math.abs(innerDotProd);\n          if (abs > largestInnerProdAbs) {\n            contactedEdgeDir = contactedEdgeDirCandidate; \n            contactedEdge = contactedEdgeCandidate;\n          }\n        } else {\n          const abs = Math.abs(innerDotProd);\n          if (abs > largestInnerProdAbs) {\n            contactedEdgeDir = {\n              dx: -contactedEdgeDirCandidate.dx,\n              dy: -contactedEdgeDirCandidate.dy,\n            };\n            contactedEdge = contactedEdgeCandidate; \n          }\n        }\n      }\n    } \n    return {\n      contactedEdgeDir: contactedEdgeDir,\n      contactedEdge: contactedEdge, \n    }; \n  },\n\n  _calculateVecToMoveByWithChosenDir(elapsedTime, sDir) {\n    if (0 == sDir.dx && 0 == sDir.dy) {\n      return cc.v2();\n    }\n    const self = this;\n    const distanceToMove = (self.speed * elapsedTime);\n    const denominator = Math.sqrt(sDir.dx * sDir.dx + sDir.dy * sDir.dy);\n    const unitProjDx = (sDir.dx / denominator);\n    const unitProjDy = (sDir.dy / denominator);\n    return cc.v2(\n      distanceToMove * unitProjDx,\n      distanceToMove * unitProjDy,\n    );\n  },\n\n  _calculateVecToMoveBy(elapsedTime) {\n    const self = this;\n    // Note that `sDir` used in this method MUST BE a copy in RAM.\n    let sDir = {\n      dx: self.activeDirection.dx,\n      dy: self.activeDirection.dy,\n    };\n\n    if (0 == sDir.dx && 0 == sDir.dy) {\n      return cc.v2();\n    }\n\n    self.firstContactedEdge = null; // Reset everytime (temporary algorithm design, might change later).\n    if (0 < self.contactedBarriers.length) {\n      /*\n       * Hardcoded to take care of only the 1st `contactedEdge` of the 1st `contactedBarrier` for now. Each `contactedBarrier` must be \"counterclockwisely convex polygonal\", otherwise sliding doesn't work! \n       *\n       */\n      const contactedBarrier = self.contactedBarriers[0]; \n      const currentSelfColliderCircle = self.node.getComponent(cc.CircleCollider);\n      const res = self._calculateTangentialMovementAttrs(currentSelfColliderCircle, contactedBarrier);\n      if (res.contactedEdge) {\n        self.firstContactedEdge = res.contactedEdge; \n        sDir = res.contactedEdgeDir;\n      }\n    } \n    return self._calculateVecToMoveByWithChosenDir(elapsedTime, sDir);\n  },\n\n  update(dt) {\n    const self = this;\n    const vecToMoveBy = self._calculateVecToMoveBy(dt);\n    if (self._canMoveBy(vecToMoveBy)) {\n      self.node.position = self.computedNewDifferentPosLocalToParentWithinCurrentFrame;\n    }\n  },\n\n  lateUpdate(dt) {\n    const self = this;\n    if (0 != self.activeDirection.dx || 0 != self.activeDirection.dy) {\n      const newScheduledDirectionInLocalCoordinate = self.ctrl.discretizeDirection(self.activeDirection.dx, self.activeDirection.dy, self.eps);\n      self.scheduleNewDirection(newScheduledDirectionInLocalCoordinate);\n    }\n    const now = new Date().getTime();\n    self.lastMovedAt = now;\n  },\n\n  onCollisionEnter(other, self) {\n    const playerScriptIns = self.node.getComponent(\"SelfPlayer\");\n    switch (other.node.name) {\n      case \"NPCPlayer\":\n        if (\"NPCPlayer\" != self.node.name) {\n          other.node.getComponent('NPCPlayer').showProfileTrigger();\n        }\n        playerScriptIns._addContactedNPCPlayers(other);\n        break;\n      case \"PolygonBoundaryBarrier\":\n        playerScriptIns._addContactedBarrier(other);\n        break;\n      case \"PolygonBoundaryShelter\":\n        break;\n      case \"PolygonBoundaryShelterZReducer\":\n        playerScriptIns._addCoveringShelterZReducer(other);\n        if (1 == playerScriptIns.coveringShelterZReducers.length) {\n          setLocalZOrder(self.node, 2);\n        }\n        break;\n      default:\n        break;\n    }\n  },\n\n  onCollisionStay(other, self) {\n    // TBD.\n  },\n\n  onCollisionExit(other, self) {\n    const playerScriptIns = self.getComponent(\"SelfPlayer\");\n    switch (other.node.name) {\n      case \"NPCPlayer\":\n        other.node.getComponent('NPCPlayer').hideProfileTrigger();\n        playerScriptIns._removeContactedNPCPlayer(other);\n        break;\n      case \"PolygonBoundaryBarrier\":\n        playerScriptIns._removeContactedBarrier(other);\n        break;\n      case \"PolygonBoundaryShelter\":\n        break;\n      case \"PolygonBoundaryShelterZReducer\":\n        playerScriptIns._removeCoveringShelterZReducer(other);\n        if (0 == playerScriptIns.coveringShelterZReducers.length) {\n          setLocalZOrder(self.node, 5);\n        }\n        break;\n      default:\n        break;\n    }\n  },\n\n  _generateRandomDirection() {\n    return ALL_DISCRETE_DIRECTIONS_CLOCKWISE[Math.floor(Math.random() * ALL_DISCRETE_DIRECTIONS_CLOCKWISE.length)];\n  },\n\n  _generateRandomDirectionExcluding(toExcludeDx, toExcludeDy) {\n    let randomDirectionList = [];\n    let exactIdx = null;\n    for (let ii = 0; ii < ALL_DISCRETE_DIRECTIONS_CLOCKWISE.length; ++ii) {\n      if (toExcludeDx != ALL_DISCRETE_DIRECTIONS_CLOCKWISE[ii].dx || toExcludeDy != ALL_DISCRETE_DIRECTIONS_CLOCKWISE[ii].dy) continue;\n      exactIdx = ii;\n      break;\n    }\n    if (null == exactIdx) {\n      return this._generateRandomDirection();\n    }\n\n    for (let ii = 0; ii < ALL_DISCRETE_DIRECTIONS_CLOCKWISE.length; ++ii) {\n      if (ii == exactIdx || ((ii - 1) % ALL_DISCRETE_DIRECTIONS_CLOCKWISE.length) == exactIdx || ((ii + 1) % ALL_DISCRETE_DIRECTIONS_CLOCKWISE.length) == exactIdx) continue;\n      randomDirectionList.push(ALL_DISCRETE_DIRECTIONS_CLOCKWISE[ii]);\n    }\n    return randomDirectionList[Math.floor(Math.random() * randomDirectionList.length)]\n  },\n\n  updateSpeed(proposedSpeed) {\n    if (0 == proposedSpeed && 0 < this.speed) {\n      this.startFrozenDisplay(); \n    } \n    if (0 < proposedSpeed && 0 == this.speed) {\n      this.stopFrozenDisplay(); \n    } \n    this.speed = proposedSpeed; \n  },\n\n  startFrozenDisplay() {\n    const self =  this;\n    const clipKey = self.scheduledDirection.dx.toString() + self.scheduledDirection.dy.toString()\n    let clip = this.attackedClips[clipKey];\n    self.animComp.play(clip);\n    self.attacked = true;\n  },\n\n  stopFrozenDisplay() {\n    const self = this;\n    const clipKey = self.scheduledDirection.dx.toString() + self.scheduledDirection.dy.toString()\n    let clip = this.clips[clipKey];\n    self.animComp.play(clip);\n    self.attacked = false;\n  },\n});\n"]}