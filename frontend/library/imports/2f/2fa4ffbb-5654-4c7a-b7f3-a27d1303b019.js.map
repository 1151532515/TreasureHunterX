{"version":3,"sources":["../../../../assets/scripts/assets/scripts/BasePlayer.js"],"names":["module","export","cc","Class","extends","Component","properties","animComp","type","Animation","default","baseSpeed","Float","speed","lastMovedAt","eps","magicLeanLowerBound","magicLeanUpperBound","start","self","contactedControlledPlayers","contactedNPCPlayers","coveringShelterZReducers","computedNewDifferentPosLocalToParentWithinCurrentFrame","actionMangerSingleton","ActionManager","scheduledDirection","dx","dy","activeDirection","onLoad","clips","canvasNode","mapNode","parent","contactedBarriers","joystickInputControllerScriptIns","getComponent","ctrl","node","play","scheduleNewDirection","newScheduledDirection","forceAnimSwitch","isBot","console","log","oldPos","newPos","clipKey","toString","attacked","attackedClips","clip","warn","JSON","stringify","_addCoveringShelterZReducer","comp","coveringShelterZReducer","_id","push","_removeCoveringShelterZReducer","filter","_addContactedBarrier","collider","contactedBarrier","_removeContactedBarrier","_addContactedControlledPlayers","aComp","uuid","_removeContactedControlledPlayer","_addContactedNPCPlayers","_removeContactedNPCPlayer","_canMoveBy","vecToMoveBy","position","add","tileCollisionManager","isOutOfMapNode","currentSelfColliderCircle","CircleCollider","nextSelfColliderCircle","length","mutatedVecToMoveBy","mul","offset","radius","contactedBarrierPolygonLocalToParentWithinCurrentFrame","points","p","Intersection","pointInPolygon","polygonCircle","firstContactedEdge","associatedBarrier","res","_calculateTangentialMovementAttrs","contactedEdge","sDir","currentSelfColliderCircleCentrePos","currentSelfColliderCircleRadius","contactedEdgeCandidateList","skinDepthThreshold","i","stPoint","edPoint","tmpVSt","sub","tmpVEd","crossProdScalar","cross","dis","pointLineDistance","st","ed","contactedEdgeDir","largestInnerProdAbs","Number","MIN_VALUE","sDirMag","Math","sqrt","contactedEdgeCandidate","tmp","contactedEdgeDirCandidate","x","y","contactedEdgeDirCandidateMag","innerDotProd","innerDotProdThresholdMag","abs","_calculateVecToMoveByWithChosenDir","elapsedTime","v2","distanceToMove","denominator","unitProjDx","unitProjDy","_calculateVecToMoveBy","update","dt","lateUpdate","newScheduledDirectionInLocalCoordinate","discretizeDirection","now","Date","getTime","onCollisionEnter","other","playerScriptIns","name","showProfileTrigger","setLocalZOrder","onCollisionStay","onCollisionExit","hideProfileTrigger","_generateRandomDirection","ALL_DISCRETE_DIRECTIONS_CLOCKWISE","floor","random","_generateRandomDirectionExcluding","toExcludeDx","toExcludeDy","randomDirectionList","exactIdx","ii","updateSpeed","proposedSpeed","startFrozenDisplay","stopFrozenDisplay"],"mappings":";;;;;;AAAAA,OAAOC,MAAP,GAAgBC,GAAGC,KAAH,CAAS;AACvBC,WAASF,GAAGG,SADW;;AAGvBC,cAAY;AACVC,cAAU;AACRC,YAAMN,GAAGO,SADD;AAERC,eAAS;AAFD,KADA;AAKVC,eAAW;AACTH,YAAMN,GAAGU,KADA;AAETF,eAAS;AAFA,KALD;AASVG,WAAO;AACLL,YAAMN,GAAGU,KADJ;AAELF,eAAS;AAFJ,KATG;AAaVI,iBAAa;AACXN,YAAMN,GAAGU,KADE;AAEXF,eAAS,CAFE,CAEA;AAFA,KAbH;AAiBVK,SAAK;AACHL,eAAS,IADN;AAEHF,YAAMN,GAAGU;AAFN,KAjBK;AAqBVI,yBAAqB;AACnBN,eAAS,KADU,EACH;AAChBF,YAAMN,GAAGU;AAFU,KArBX;AAyBVK,yBAAqB;AACnBP,eAAS,KADU,EACH;AAChBF,YAAMN,GAAGU;AAFU;AAzBX,GAHW;;AAkCvB;AACAM,OAnCuB,mBAmCf;AACN,QAAMC,OAAO,IAAb;AACAA,SAAKC,0BAAL,GAAkC,EAAlC;AACAD,SAAKE,mBAAL,GAA2B,EAA3B;AACAF,SAAKG,wBAAL,GAAgC,EAAhC;;AAEAH,SAAKI,sDAAL,GAA8D,IAA9D;AACAJ,SAAKK,qBAAL,GAA6B,IAAItB,GAAGuB,aAAP,EAA7B;AACAN,SAAKO,kBAAL,GAA0B;AACxBC,UAAI,GADoB;AAExBC,UAAI;AAFoB,KAA1B;;AAKAT,SAAKU,eAAL,GAAuB;AACrBF,UAAI,GADiB;AAErBC,UAAI;AAFiB,KAAvB;AAID,GApDsB;AAsDvBE,QAtDuB,oBAsDd;AACP,QAAMX,OAAO,IAAb;AACAA,SAAKY,KAAL,GAAa;AACX,YAAM,KADK;AAEX,aAAO,QAFI;AAGX,aAAO,MAHI;AAIX,YAAM,OAJK;AAKX,aAAO,SALI;AAMX,YAAM,UANK;AAOX,cAAQ,YAPG;AAQX,aAAO;AARI,KAAb;AAUA,QAAMC,aAAab,KAAKc,OAAL,CAAaC,MAAhC;AACAf,SAAKgB,iBAAL,GAAyB,EAAzB;AACA,QAAMC,mCAAmCJ,WAAWK,YAAX,CAAwB,oBAAxB,CAAzC;AACAlB,SAAKmB,IAAL,GAAYF,gCAAZ;AACAjB,SAAKZ,QAAL,GAAgBY,KAAKoB,IAAL,CAAUF,YAAV,CAAuBnC,GAAGO,SAA1B,CAAhB;AACAU,SAAKZ,QAAL,CAAciC,IAAd;AACD,GAxEsB;AA0EvBC,sBA1EuB,gCA0EFC,qBA1EE,EA0EqBC,eA1ErB,EA0EsC;AAC3D,QAAI,CAACD,qBAAL,EAA4B;AAC1B;AACD;;AAED,QAAG,KAAKE,KAAR,EAAc;AACZ,UAAGF,sBAAsBf,EAAtB,IAA4B,KAAKD,kBAAL,CAAwBC,EAApD,IAA0De,sBAAsBd,EAAtB,IAA4B,KAAKF,kBAAL,CAAwBE,EAAjH,EAAoH;AACpH;AACAiB,gBAAQC,GAAR,gEAA4B,KAAKC,MAAjC,2DAAqD,KAAKC,MAA1D,6BAAyE,KAAKtB,kBAAL,CAAwBC,EAAjG,WAAyG,KAAKD,kBAAL,CAAwBE,EAAjI,gCAA+Ic,sBAAsBf,EAArK,aAA+Ke,sBAAsBd,EAArM;AACA;AACC;AAEF;;AAGD,QAAIe,mBAAmB,QAAQ,KAAKjB,kBAAhC,IAAuDgB,sBAAsBf,EAAtB,IAA4B,KAAKD,kBAAL,CAAwBC,EAApD,IAA0De,sBAAsBd,EAAtB,IAA4B,KAAKF,kBAAL,CAAwBE,EAAzK,EAA8K;AAC5K,WAAKF,kBAAL,GAA0BgB,qBAA1B;AACA,UAAMO,UAAUP,sBAAsBf,EAAtB,CAAyBuB,QAAzB,KAAsCR,sBAAsBd,EAAtB,CAAyBsB,QAAzB,EAAtD;AACA,UAAMnB,QAAS,KAAKoB,QAAL,GAAgB,KAAKC,aAArB,GAAqC,KAAKrB,KAAzD;AACA,UAAIsB,OAAOtB,MAAMkB,OAAN,CAAX;AACA,UAAI,CAACI,IAAL,EAAW;AACT;AACA,YAAI,MAAMX,sBAAsBf,EAA5B,IAAkC,MAAMe,sBAAsBd,EAAlE,EAAsE;AACpE1B,aAAGoD,IAAH,CAAQ,0BAA0BL,OAA1B,GAAoC,eAApC,GAAsDI,IAAtD,GAA6D,GAArE;AACD;AACF,OALD,MAKO;AACL,aAAK9C,QAAL,CAAciC,IAAd,CAAmBa,IAAnB;AACA,YAAI,KAAKF,QAAT,EAAmB;AACjBjD,aAAG4C,GAAH,4CAAgDG,OAAhD,kBAAoEI,IAApE,kCAAqGE,KAAKC,SAAL,CAAe,KAAK3B,eAApB,CAArG,qCAAyK0B,KAAKC,SAAL,CAAe,KAAK9B,kBAApB,CAAzK;AACD;AACF;AACF;AACF,GA1GsB;AA4GvB+B,6BA5GuB,uCA4GKC,IA5GL,EA4GW;AAChC,QAAMvC,OAAO,IAAb;AADgC;AAAA;AAAA;;AAAA;AAEhC,2BAAoCA,KAAKG,wBAAzC,8HAAmE;AAAA,YAA1DqC,uBAA0D;;AACjE,YAAIA,wBAAwBC,GAAxB,IAA+BF,KAAKE,GAAxC,EAA6C;AAC3C,iBAAO,KAAP;AACD;AACF;AAN+B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOhCzC,SAAKG,wBAAL,CAA8BuC,IAA9B,CAAmCH,IAAnC;AACA,WAAO,IAAP;AACD,GArHsB;AAuHvBI,gCAvHuB,0CAuHQJ,IAvHR,EAuHc;AACnC,QAAMvC,OAAO,IAAb;AACAA,SAAKG,wBAAL,GAAgCH,KAAKG,wBAAL,CAA8ByC,MAA9B,CAAqC,UAACJ,uBAAD,EAA6B;AAChG,aAAOA,wBAAwBC,GAAxB,IAA+BF,KAAKE,GAA3C;AACD,KAF+B,CAAhC;AAGA,WAAO,IAAP;AACD,GA7HsB;AA+HvBI,sBA/HuB,gCA+HFC,QA/HE,EA+HQ;AAC7B,QAAM9C,OAAO,IAAb;AACA,QAAI,CAACA,KAAKgB,iBAAV,EAA6B;AAC3BjC,SAAG4C,GAAH,CAAO,gDAAgD3B,KAAKgB,iBAA5D;AACD;AAJ4B;AAAA;AAAA;;AAAA;AAK7B,4BAA6BhB,KAAKgB,iBAAlC,mIAAqD;AAAA,YAA5C+B,gBAA4C;;AACnD,YAAIA,iBAAiBN,GAAjB,IAAwBK,SAASL,GAArC,EAA0C;AACxC,iBAAO,KAAP;AACD;AACF;AAT4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAU7BzC,SAAKgB,iBAAL,CAAuB0B,IAAvB,CAA4BI,QAA5B;AACA,WAAO,IAAP;AACD,GA3IsB;AA6IvBE,yBA7IuB,mCA6ICF,QA7ID,EA6IW;AAChC,QAAM9C,OAAO,IAAb;AACAA,SAAKgB,iBAAL,GAAyBhB,KAAKgB,iBAAL,CAAuB4B,MAAvB,CAA8B,UAACG,gBAAD,EAAsB;AAC3E,aAAOA,iBAAiBN,GAAjB,IAAwBK,SAASL,GAAxC;AACD,KAFwB,CAAzB;AAGA,WAAO,IAAP;AACD,GAnJsB;AAqJvBQ,gCArJuB,0CAqJQV,IArJR,EAqJc;AACnC,QAAMvC,OAAO,IAAb;AADmC;AAAA;AAAA;;AAAA;AAEnC,4BAAkBA,KAAKC,0BAAvB,mIAAmD;AAAA,YAA1CiD,KAA0C;;AACjD,YAAIA,MAAMC,IAAN,IAAcZ,KAAKY,IAAvB,EAA6B;AAC3B,iBAAO,KAAP;AACD;AACF;AANkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOnCnD,SAAKC,0BAAL,CAAgCyC,IAAhC,CAAqCH,IAArC;AACA,WAAO,IAAP;AACD,GA9JsB;AAgKvBa,kCAhKuB,4CAgKUb,IAhKV,EAgKgB;AACrC,QAAMvC,OAAO,IAAb;AACAA,SAAKC,0BAAL,GAAkCD,KAAKC,0BAAL,CAAgC2C,MAAhC,CAAuC,UAACM,KAAD,EAAW;AAClF,aAAOA,MAAMC,IAAN,IAAcZ,KAAKY,IAA1B;AACD,KAFiC,CAAlC;AAGA,WAAO,IAAP;AACD,GAtKsB;AAwKvBE,yBAxKuB,mCAwKCd,IAxKD,EAwKO;AAC5B,QAAMvC,OAAO,IAAb;AAD4B;AAAA;AAAA;;AAAA;AAE5B,4BAAkBA,KAAKE,mBAAvB,mIAA4C;AAAA,YAAnCgD,KAAmC;;AAC1C,YAAIA,MAAMC,IAAN,IAAcZ,KAAKY,IAAvB,EAA6B;AAC3B,iBAAO,KAAP;AACD;AACF;AAN2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAO5BnD,SAAKE,mBAAL,CAAyBwC,IAAzB,CAA8BH,IAA9B;AACA,WAAO,IAAP;AACD,GAjLsB;AAmLvBe,2BAnLuB,qCAmLGf,IAnLH,EAmLS;AAC9B,QAAMvC,OAAO,IAAb;AACAA,SAAKE,mBAAL,GAA2BF,KAAKE,mBAAL,CAAyB0C,MAAzB,CAAgC,UAACM,KAAD,EAAW;AACpE,aAAOA,MAAMC,IAAN,IAAcZ,KAAKY,IAA1B;AACD,KAF0B,CAA3B;AAGA,WAAO,IAAP;AACD,GAzLsB;AA2LvBI,YA3LuB,sBA2LZC,WA3LY,EA2LC;AACtB,QAAMxD,OAAO,IAAb;AACA,QAAMI,yDAAyDJ,KAAKoB,IAAL,CAAUqC,QAAV,CAAmBC,GAAnB,CAAuBF,WAAvB,CAA/D;AACAxD,SAAKI,sDAAL,GAA8DA,sDAA9D;;AAEA,QAAIuD,qBAAqBC,cAArB,CAAoC5D,KAAKc,OAAzC,EAAkDV,sDAAlD,CAAJ,EAA+G;AAC7G,aAAO,KAAP;AACD;;AAED,QAAMyD,4BAA4B7D,KAAKoB,IAAL,CAAUF,YAAV,CAAuBnC,GAAG+E,cAA1B,CAAlC;AACA,QAAIC,yBAAyB,IAA7B;AACA,QAAI,IAAI/D,KAAKgB,iBAAL,CAAuBgD,MAA/B,EAAuC;AACrC;AACA,UAAMC,qBAAqBT,YAAYU,GAAZ,CAAgB,CAAhB,CAA3B,CAFqC,CAEU;AAC/CH,+BAAyB;AACvBN,kBAAUzD,KAAKoB,IAAL,CAAUqC,QAAV,CAAmBC,GAAnB,CAAuBO,kBAAvB,EAA2CP,GAA3C,CAA+CG,0BAA0BM,MAAzE,CADa;AAEvBC,gBAAQP,0BAA0BO;AAFX,OAAzB;AAID,KAPD,MAOO;AACLL,+BAAyB;AACvBN,kBAAUrD,uDAAuDsD,GAAvD,CAA2DG,0BAA0BM,MAArF,CADa;AAEvBC,gBAAQP,0BAA0BO;AAFX,OAAzB;AAID;;AAvBqB;AAAA;AAAA;;AAAA;AAyBtB,4BAA6BpE,KAAKgB,iBAAlC,mIAAqD;AAAA,YAA5C+B,gBAA4C;;AACnD,YAAIsB,yDAAyD,EAA7D;AADmD;AAAA;AAAA;;AAAA;AAEnD,gCAActB,iBAAiBuB,MAA/B,mIAAuC;AAAA,gBAA9BC,CAA8B;;AACrCF,mEAAuD3B,IAAvD,CAA4DK,iBAAiB3B,IAAjB,CAAsBqC,QAAtB,CAA+BC,GAA/B,CAAmCa,CAAnC,CAA5D;AACD;AAJkD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKnD,YAAIxF,GAAGyF,YAAH,CAAgBC,cAAhB,CAA+BV,uBAAuBN,QAAtD,EAAgEY,sDAAhE,CAAJ,EAA6H;AAC3H;AACA,iBAAO,KAAP;AACD;AACD,YAAItF,GAAGyF,YAAH,CAAgBE,aAAhB,CAA8BL,sDAA9B,EAAsFN,sBAAtF,CAAJ,EAAmH;AACjH,cAAI,QAAQ/D,KAAK2E,kBAAjB,EAAqC;AACnC,mBAAO,KAAP;AACD;AACD,cAAI,QAAQ3E,KAAK2E,kBAAb,IAAmC3E,KAAK2E,kBAAL,CAAwBC,iBAAxB,IAA6C7B,gBAApF,EAAsG;AACpG,gBAAM8B,MAAM7E,KAAK8E,iCAAL,CAAuCf,sBAAvC,EAA+DhB,gBAA/D,CAAZ;AACA,gBAAI,QAAQ8B,IAAIE,aAAhB,EAA+B;AAC7B;AACA,qBAAO,KAAP;AACD;AACF;AACF;AACF;AA9CqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgDtB,WAAO,IAAP;;AAEA;;;;;;;;;;AAUD,GAvPsB;AAyPvBD,mCAzPuB,6CAyPWjB,yBAzPX,EAyPsCd,gBAzPtC,EAyPwD;AAC7E;;;;;;AAMA,QAAM/C,OAAO,IAAb;AACA,QAAMgF,OAAOhF,KAAKU,eAAlB;AACA,QAAMuE,qCAAsCpB,0BAA0BJ,QAA1B,GAAqCI,0BAA0BJ,QAA/D,GAA0EzD,KAAKoB,IAAL,CAAUqC,QAAV,CAAmBC,GAAnB,CAAuBG,0BAA0BM,MAAjD,CAAtH;AACA,QAAMe,kCAAkCrB,0BAA0BO,MAAlE;AACA,QAAIe,6BAA6B,EAAjC;AACA,QAAIC,qBAAqB,OAAKF,+BAA9B;AACA,SAAK,IAAIG,IAAI,CAAb,EAAgBA,IAAItC,iBAAiBuB,MAAjB,CAAwBN,MAA5C,EAAoD,EAAEqB,CAAtD,EAAyD;AACvD,UAAMC,UAAUvC,iBAAiBuB,MAAjB,CAAwBe,CAAxB,EAA2B3B,GAA3B,CAA+BX,iBAAiBoB,MAAhD,EAAwDT,GAAxD,CAA4DX,iBAAiB3B,IAAjB,CAAsBqC,QAAlF,CAAhB;AACA,UAAM8B,UAAWF,KAAKtC,iBAAiBuB,MAAjB,CAAwBN,MAAxB,GAAiC,CAAtC,GAA0CjB,iBAAiBuB,MAAjB,CAAwB,CAAxB,EAA2BZ,GAA3B,CAA+BX,iBAAiBoB,MAAhD,EAAwDT,GAAxD,CAA4DX,iBAAiB3B,IAAjB,CAAsBqC,QAAlF,CAA1C,GAAwIV,iBAAiBuB,MAAjB,CAAwB,IAAIe,CAA5B,EAA+B3B,GAA/B,CAAmCX,iBAAiBoB,MAApD,EAA4DT,GAA5D,CAAgEX,iBAAiB3B,IAAjB,CAAsBqC,QAAtF,CAAzJ;AACA,UAAM+B,SAASF,QAAQG,GAAR,CAAYR,kCAAZ,CAAf;AACA,UAAMS,SAASH,QAAQE,GAAR,CAAYR,kCAAZ,CAAf;AACA,UAAMU,kBAAkBH,OAAOI,KAAP,CAAaF,MAAb,CAAxB;AACA,UAAI,IAAIC,eAAR,EAAyB;AACvB;AACA;AACD;AACD,UAAME,MAAM9G,GAAGyF,YAAH,CAAgBsB,iBAAhB,CAAkCb,kCAAlC,EAAsEK,OAAtE,EAA+EC,OAA/E,EAAwF,IAAxF,CAAZ;AACA,UAAIM,MAAMX,+BAAV,EAA2C;AAC3C,UAAIW,MAAMT,kBAAV,EAA8B;AAC9BD,iCAA2BzC,IAA3B,CAAgC;AAC9BqD,YAAIT,OAD0B;AAE9BU,YAAIT,OAF0B;AAG9BX,2BAAmB7B;AAHW,OAAhC;AAKD;AACD,QAAIgC,gBAAgB,IAApB;AACA,QAAIkB,mBAAmB,IAAvB;AACA,QAAIC,sBAAsBC,OAAOC,SAAjC;;AAEA,QAAI,IAAIjB,2BAA2BnB,MAAnC,EAA2C;AACzC,UAAMqC,UAAUC,KAAKC,IAAL,CAAUvB,KAAKxE,EAAL,GAAUwE,KAAKxE,EAAf,GAAoBwE,KAAKvE,EAAL,GAAUuE,KAAKvE,EAA7C,CAAhB;AADyC;AAAA;AAAA;;AAAA;AAEzC,8BAAmC0E,0BAAnC,mIAA+D;AAAA,cAAtDqB,sBAAsD;;AAC7D,cAAMC,MAAMD,uBAAuBR,EAAvB,CAA0BP,GAA1B,CAA8Be,uBAAuBT,EAArD,CAAZ;AACA,cAAMW,4BAA4B;AAChClG,gBAAIiG,IAAIE,CADwB;AAEhClG,gBAAIgG,IAAIG;AAFwB,WAAlC;AAIA,cAAMC,+BAA+BP,KAAKC,IAAL,CAAUG,0BAA0BlG,EAA1B,GAA+BkG,0BAA0BlG,EAAzD,GAA8DkG,0BAA0BjG,EAA1B,GAA+BiG,0BAA0BjG,EAAjI,CAArC;AACA,cAAMqG,eAAe,CAAC9B,KAAKxE,EAAL,GAAUkG,0BAA0BlG,EAApC,GAAyCwE,KAAKvE,EAAL,GAAUiG,0BAA0BjG,EAA9E,KAAmF4F,UAAUQ,4BAA7F,CAArB;AACA,cAAME,2BAA2B,GAAjC;AACA,cAAK,IAAID,YAAJ,IAAoBA,eAAe,CAACC,wBAArC,IAAmE,IAAID,YAAJ,IAAoBA,eAAeC,wBAA1G,EAAqI;AACnI;AACA;AACD,WAHD,MAGO,IAAID,eAAe,CAAnB,EAAsB;AAC3B,gBAAME,MAAMV,KAAKU,GAAL,CAASF,YAAT,CAAZ;AACA,gBAAIE,MAAMd,mBAAV,EAA+B;AAC7BD,iCAAmBS,yBAAnB;AACA3B,8BAAgByB,sBAAhB;AACD;AACF,WANM,MAMA;AACL,gBAAMQ,OAAMV,KAAKU,GAAL,CAASF,YAAT,CAAZ;AACA,gBAAIE,OAAMd,mBAAV,EAA+B;AAC7BD,iCAAmB;AACjBzF,oBAAI,CAACkG,0BAA0BlG,EADd;AAEjBC,oBAAI,CAACiG,0BAA0BjG;AAFd,eAAnB;AAIAsE,8BAAgByB,sBAAhB;AACD;AACF;AACF;AA9BwC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+B1C;AACD,WAAO;AACLP,wBAAkBA,gBADb;AAELlB,qBAAeA;AAFV,KAAP;AAID,GAjUsB;AAmUvBkC,oCAnUuB,8CAmUYC,WAnUZ,EAmUyBlC,IAnUzB,EAmU+B;AACpD,QAAI,KAAKA,KAAKxE,EAAV,IAAgB,KAAKwE,KAAKvE,EAA9B,EAAkC;AAChC,aAAO1B,GAAGoI,EAAH,EAAP;AACD;AACD,QAAMnH,OAAO,IAAb;AACA,QAAMoH,iBAAkBpH,KAAKN,KAAL,GAAawH,WAArC;AACA,QAAMG,cAAcf,KAAKC,IAAL,CAAUvB,KAAKxE,EAAL,GAAUwE,KAAKxE,EAAf,GAAoBwE,KAAKvE,EAAL,GAAUuE,KAAKvE,EAA7C,CAApB;AACA,QAAM6G,aAActC,KAAKxE,EAAL,GAAU6G,WAA9B;AACA,QAAME,aAAcvC,KAAKvE,EAAL,GAAU4G,WAA9B;AACA,WAAOtI,GAAGoI,EAAH,CACLC,iBAAiBE,UADZ,EAELF,iBAAiBG,UAFZ,CAAP;AAID,GAhVsB;AAkVvBC,uBAlVuB,iCAkVDN,WAlVC,EAkVY;AACjC,QAAMlH,OAAO,IAAb;AACA;AACA,QAAIgF,OAAO;AACTxE,UAAIR,KAAKU,eAAL,CAAqBF,EADhB;AAETC,UAAIT,KAAKU,eAAL,CAAqBD;AAFhB,KAAX;;AAKA,QAAI,KAAKuE,KAAKxE,EAAV,IAAgB,KAAKwE,KAAKvE,EAA9B,EAAkC;AAChC,aAAO1B,GAAGoI,EAAH,EAAP;AACD;;AAEDnH,SAAK2E,kBAAL,GAA0B,IAA1B,CAZiC,CAYD;AAChC,QAAI,IAAI3E,KAAKgB,iBAAL,CAAuBgD,MAA/B,EAAuC;AACrC;;;;AAIA,UAAMjB,mBAAmB/C,KAAKgB,iBAAL,CAAuB,CAAvB,CAAzB;AACA,UAAM6C,4BAA4B7D,KAAKoB,IAAL,CAAUF,YAAV,CAAuBnC,GAAG+E,cAA1B,CAAlC;AACA,UAAMe,MAAM7E,KAAK8E,iCAAL,CAAuCjB,yBAAvC,EAAkEd,gBAAlE,CAAZ;AACA,UAAI8B,IAAIE,aAAR,EAAuB;AACrB/E,aAAK2E,kBAAL,GAA0BE,IAAIE,aAA9B;AACAC,eAAOH,IAAIoB,gBAAX;AACD;AACF;AACD,WAAOjG,KAAKiH,kCAAL,CAAwCC,WAAxC,EAAqDlC,IAArD,CAAP;AACD,GA7WsB;AA+WvByC,QA/WuB,kBA+WhBC,EA/WgB,EA+WZ;AACT,QAAM1H,OAAO,IAAb;AACA,QAAMwD,cAAcxD,KAAKwH,qBAAL,CAA2BE,EAA3B,CAApB;AACA,QAAI1H,KAAKuD,UAAL,CAAgBC,WAAhB,CAAJ,EAAkC;AAChCxD,WAAKoB,IAAL,CAAUqC,QAAV,GAAqBzD,KAAKI,sDAA1B;AACD;AACF,GArXsB;AAuXvBuH,YAvXuB,sBAuXZD,EAvXY,EAuXR;AACb,QAAM1H,OAAO,IAAb;AACA,QAAI,KAAKA,KAAKU,eAAL,CAAqBF,EAA1B,IAAgC,KAAKR,KAAKU,eAAL,CAAqBD,EAA9D,EAAkE;AAAC;AACjE,UAAMmH,yCAAyC5H,KAAKmB,IAAL,CAAU0G,mBAAV,CAA8B7H,KAAKU,eAAL,CAAqBF,EAAnD,EAAuDR,KAAKU,eAAL,CAAqBD,EAA5E,EAAgFT,KAAKJ,GAArF,CAA/C;AACAI,WAAKsB,oBAAL,CAA0BsG,sCAA1B,EAAkE,KAAlE;AACD;AACD,QAAME,MAAM,IAAIC,IAAJ,GAAWC,OAAX,EAAZ;AACAhI,SAAKL,WAAL,GAAmBmI,GAAnB;AACD,GA/XsB;AAiYvBG,kBAjYuB,4BAiYNC,KAjYM,EAiYClI,IAjYD,EAiYO;AAC5B,QAAMmI,kBAAkBnI,KAAKoB,IAAL,CAAUF,YAAV,CAAuB,YAAvB,CAAxB;AACA,YAAQgH,MAAM9G,IAAN,CAAWgH,IAAnB;AACE,WAAK,WAAL;AACE,YAAI,eAAepI,KAAKoB,IAAL,CAAUgH,IAA7B,EAAmC;AACjCF,gBAAM9G,IAAN,CAAWF,YAAX,CAAwB,WAAxB,EAAqCmH,kBAArC;AACD;AACDF,wBAAgB9E,uBAAhB,CAAwC6E,KAAxC;AACA;AACF,WAAK,wBAAL;AACEC,wBAAgBtF,oBAAhB,CAAqCqF,KAArC;AACA;AACF,WAAK,wBAAL;AACE;AACF,WAAK,gCAAL;AACEC,wBAAgB7F,2BAAhB,CAA4C4F,KAA5C;AACA,YAAI,KAAKC,gBAAgBhI,wBAAhB,CAAyC6D,MAAlD,EAA0D;AACxDsE,yBAAetI,KAAKoB,IAApB,EAA0B,CAA1B;AACD;AACD;AACF;AACE;AAnBJ;AAqBD,GAxZsB;AA0ZvBmH,iBA1ZuB,2BA0ZPL,KA1ZO,EA0ZAlI,IA1ZA,EA0ZM;AAC3B;AACD,GA5ZsB;AA8ZvBwI,iBA9ZuB,2BA8ZPN,KA9ZO,EA8ZAlI,IA9ZA,EA8ZM;AAC3B,QAAMmI,kBAAkBnI,KAAKkB,YAAL,CAAkB,YAAlB,CAAxB;AACA,YAAQgH,MAAM9G,IAAN,CAAWgH,IAAnB;AACE,WAAK,WAAL;AACEF,cAAM9G,IAAN,CAAWF,YAAX,CAAwB,WAAxB,EAAqCuH,kBAArC;AACAN,wBAAgB7E,yBAAhB,CAA0C4E,KAA1C;AACA;AACF,WAAK,wBAAL;AACEC,wBAAgBnF,uBAAhB,CAAwCkF,KAAxC;AACA;AACF,WAAK,wBAAL;AACE;AACF,WAAK,gCAAL;AACEC,wBAAgBxF,8BAAhB,CAA+CuF,KAA/C;AACA,YAAI,KAAKC,gBAAgBhI,wBAAhB,CAAyC6D,MAAlD,EAA0D;AACxDsE,yBAAetI,KAAKoB,IAApB,EAA0B,CAA1B;AACD;AACD;AACF;AACE;AAjBJ;AAmBD,GAnbsB;AAqbvBsH,0BArbuB,sCAqbI;AACzB,WAAOC,kCAAkCrC,KAAKsC,KAAL,CAAWtC,KAAKuC,MAAL,KAAgBF,kCAAkC3E,MAA7D,CAAlC,CAAP;AACD,GAvbsB;AAybvB8E,mCAzbuB,6CAybWC,WAzbX,EAybwBC,WAzbxB,EAybqC;AAC1D,QAAIC,sBAAsB,EAA1B;AACA,QAAIC,WAAW,IAAf;AACA,SAAK,IAAIC,KAAK,CAAd,EAAiBA,KAAKR,kCAAkC3E,MAAxD,EAAgE,EAAEmF,EAAlE,EAAsE;AACpE,UAAIJ,eAAeJ,kCAAkCQ,EAAlC,EAAsC3I,EAArD,IAA2DwI,eAAeL,kCAAkCQ,EAAlC,EAAsC1I,EAApH,EAAwH;AACxHyI,iBAAWC,EAAX;AACA;AACD;AACD,QAAI,QAAQD,QAAZ,EAAsB;AACpB,aAAO,KAAKR,wBAAL,EAAP;AACD;;AAED,SAAK,IAAIS,MAAK,CAAd,EAAiBA,MAAKR,kCAAkC3E,MAAxD,EAAgE,EAAEmF,GAAlE,EAAsE;AACpE,UAAIA,OAAMD,QAAN,IAAmB,CAACC,MAAK,CAAN,IAAWR,kCAAkC3E,MAA9C,IAAyDkF,QAA3E,IAAwF,CAACC,MAAK,CAAN,IAAWR,kCAAkC3E,MAA9C,IAAyDkF,QAApJ,EAA8J;AAC9JD,0BAAoBvG,IAApB,CAAyBiG,kCAAkCQ,GAAlC,CAAzB;AACD;AACD,WAAOF,oBAAoB3C,KAAKsC,KAAL,CAAWtC,KAAKuC,MAAL,KAAgBI,oBAAoBjF,MAA/C,CAApB,CAAP;AACD,GA1csB;AA4cvBoF,aA5cuB,uBA4cXC,aA5cW,EA4cI;AACzB,QAAI,KAAKA,aAAL,IAAsB,IAAI,KAAK3J,KAAnC,EAA0C;AACxC,WAAK4J,kBAAL;AACD;AACD,QAAI,IAAID,aAAJ,IAAqB,KAAK,KAAK3J,KAAnC,EAA0C;AACxC,WAAK6J,iBAAL;AACD;AACD,SAAK7J,KAAL,GAAa2J,aAAb;AACD,GApdsB;AAsdvBC,oBAtduB,gCAsdF;AACnB,QAAMtJ,OAAQ,IAAd;AACAA,SAAKgC,QAAL,GAAgB,IAAhB;AACAhC,SAAKsB,oBAAL,CAA0BtB,KAAKO,kBAA/B,EAAmD,IAAnD;AACD,GA1dsB;AA4dvBgJ,mBA5duB,+BA4dH;AAClB,QAAMvJ,OAAO,IAAb;AACAA,SAAKgC,QAAL,GAAgB,KAAhB;AACAhC,SAAKsB,oBAAL,CAA0BtB,KAAKO,kBAA/B,EAAmD,IAAnD;AACD;AAhesB,CAAT,CAAhB","file":"BasePlayer.js","sourceRoot":"../../../../assets/scripts","sourcesContent":["module.export = cc.Class({\n  extends: cc.Component,\n\n  properties: {\n    animComp: {\n      type: cc.Animation,\n      default: null,\n    },\n    baseSpeed: {\n      type: cc.Float,\n      default: 300,\n    },\n    speed: {\n      type: cc.Float,\n      default: 300\n    },\n    lastMovedAt: {\n      type: cc.Float,\n      default: 0 // In \"GMT milliseconds\"\n    },\n    eps: {\n      default: 0.10,\n      type: cc.Float\n    },\n    magicLeanLowerBound: {\n      default: 0.414, // Tangent of (PI/8).\n      type: cc.Float\n    },\n    magicLeanUpperBound: {\n      default: 2.414, // Tangent of (3*PI/8).\n      type: cc.Float\n    },\n  },\n\n  // LIFE-CYCLE CALLBACKS:\n  start() {\n    const self = this;\n    self.contactedControlledPlayers = [];\n    self.contactedNPCPlayers = [];\n    self.coveringShelterZReducers = [];\n\n    self.computedNewDifferentPosLocalToParentWithinCurrentFrame = null;\n    self.actionMangerSingleton = new cc.ActionManager();\n    self.scheduledDirection = {\n      dx: 0.0,\n      dy: 0.0\n    };\n\n    self.activeDirection = {\n      dx: 0.0,\n      dy: 0.0\n    };\n  },\n\n  onLoad() {\n    const self = this;\n    self.clips = {\n      '01': 'Top',\n      '0-1': 'Bottom',\n      '-20': 'Left',\n      '20': 'Right',\n      '-21': 'TopLeft',\n      '21': 'TopRight',\n      '-2-1': 'BottomLeft',\n      '2-1': 'BottomRight'\n    };\n    const canvasNode = self.mapNode.parent;\n    self.contactedBarriers = [];\n    const joystickInputControllerScriptIns = canvasNode.getComponent(\"TouchEventsManager\");\n    self.ctrl = joystickInputControllerScriptIns;\n    self.animComp = self.node.getComponent(cc.Animation);\n    self.animComp.play();\n  },\n\n  scheduleNewDirection(newScheduledDirection, forceAnimSwitch) {\n    if (!newScheduledDirection) {\n      return;\n    }\n\n    if(this.isBot){\n      if(newScheduledDirection.dx != this.scheduledDirection.dx || newScheduledDirection.dy != this.scheduledDirection.dy){\n      //console.log(newScheduledDirection, this.activeDirection, this.newpos);\n      console.log(`转换方向: 之前的位置: ${this.oldPos} 应当移动到的位置: ${this.newPos} 旧方向:x${this.scheduledDirection.dx}, y${this.scheduledDirection.dy} 新方向: x: ${newScheduledDirection.dx}, y: ${newScheduledDirection.dy}`)\n      //console.log(this.newScheduledDirection,this.toMoveByVec, this.toMoveByVecMag )\n      }\n\n    }\n\n\n    if (forceAnimSwitch || null == this.scheduledDirection || (newScheduledDirection.dx != this.scheduledDirection.dx || newScheduledDirection.dy != this.scheduledDirection.dy)) {\n      this.scheduledDirection = newScheduledDirection;\n      const clipKey = newScheduledDirection.dx.toString() + newScheduledDirection.dy.toString();\n      const clips = (this.attacked ? this.attackedClips : this.clips); \n      let clip = clips[clipKey];\n      if (!clip) {\n        // Keep playing the current anim.\n        if (0 !== newScheduledDirection.dx || 0 !== newScheduledDirection.dy) {\n          cc.warn('Clip for clipKey === ' + clipKey + ' is invalid: ' + clip + '.');\n        }\n      } else {\n        this.animComp.play(clip);\n        if (this.attacked) {\n          cc.log(`Attacked, switching to play clipKey = ${clipKey}, clip == ${clip}, this.activeDirection == ${JSON.stringify(this.activeDirection)}, this.scheduledDirection == ${JSON.stringify(this.scheduledDirection)}.`);\n        }\n      }\n    }\n  },\n\n  _addCoveringShelterZReducer(comp) {\n    const self = this;\n    for (let coveringShelterZReducer of self.coveringShelterZReducers) {\n      if (coveringShelterZReducer._id == comp._id) {\n        return false;\n      }\n    }\n    self.coveringShelterZReducers.push(comp);\n    return true;\n  },\n\n  _removeCoveringShelterZReducer(comp) {\n    const self = this;\n    self.coveringShelterZReducers = self.coveringShelterZReducers.filter((coveringShelterZReducer) => {\n      return coveringShelterZReducer._id != comp._id;\n    });\n    return true;\n  },\n\n  _addContactedBarrier(collider) {\n    const self = this;\n    if (!self.contactedBarriers) {\n      cc.log(\"self.contactedBarriers is null or undefined\" + self.contactedBarriers)\n    }\n    for (let contactedBarrier of self.contactedBarriers) {\n      if (contactedBarrier._id == collider._id) {\n        return false;\n      }\n    }\n    self.contactedBarriers.push(collider);\n    return true;\n  },\n\n  _removeContactedBarrier(collider) {\n    const self = this;\n    self.contactedBarriers = self.contactedBarriers.filter((contactedBarrier) => {\n      return contactedBarrier._id != collider._id;\n    });\n    return true;\n  },\n\n  _addContactedControlledPlayers(comp) {\n    const self = this;\n    for (let aComp of self.contactedControlledPlayers) {\n      if (aComp.uuid == comp.uuid) {\n        return false;\n      }\n    }\n    self.contactedControlledPlayers.push(comp);\n    return true;\n  },\n\n  _removeContactedControlledPlayer(comp) {\n    const self = this;\n    self.contactedControlledPlayers = self.contactedControlledPlayers.filter((aComp) => {\n      return aComp.uuid != comp.uuid;\n    });\n    return true;\n  },\n\n  _addContactedNPCPlayers(comp) {\n    const self = this;\n    for (let aComp of self.contactedNPCPlayers) {\n      if (aComp.uuid == comp.uuid) {\n        return false;\n      }\n    }\n    self.contactedNPCPlayers.push(comp);\n    return true;\n  },\n\n  _removeContactedNPCPlayer(comp) {\n    const self = this;\n    self.contactedNPCPlayers = self.contactedNPCPlayers.filter((aComp) => {\n      return aComp.uuid != comp.uuid;\n    });\n    return true;\n  },\n\n  _canMoveBy(vecToMoveBy) {\n    const self = this;\n    const computedNewDifferentPosLocalToParentWithinCurrentFrame = self.node.position.add(vecToMoveBy);\n    self.computedNewDifferentPosLocalToParentWithinCurrentFrame = computedNewDifferentPosLocalToParentWithinCurrentFrame;\n\n    if (tileCollisionManager.isOutOfMapNode(self.mapNode, computedNewDifferentPosLocalToParentWithinCurrentFrame)) {\n      return false;\n    }\n\n    const currentSelfColliderCircle = self.node.getComponent(cc.CircleCollider);\n    let nextSelfColliderCircle = null;\n    if (0 < self.contactedBarriers.length) {\n      /* To avoid unexpected buckling. */\n      const mutatedVecToMoveBy = vecToMoveBy.mul(5); // To help it escape the engaged `contactedBarriers`.\n      nextSelfColliderCircle = {\n        position: self.node.position.add(mutatedVecToMoveBy).add(currentSelfColliderCircle.offset),\n        radius: currentSelfColliderCircle.radius,\n      };\n    } else {\n      nextSelfColliderCircle = {\n        position: computedNewDifferentPosLocalToParentWithinCurrentFrame.add(currentSelfColliderCircle.offset),\n        radius: currentSelfColliderCircle.radius,\n      };\n    }\n\n    for (let contactedBarrier of self.contactedBarriers) {\n      let contactedBarrierPolygonLocalToParentWithinCurrentFrame = [];\n      for (let p of contactedBarrier.points) {\n        contactedBarrierPolygonLocalToParentWithinCurrentFrame.push(contactedBarrier.node.position.add(p));\n      }\n      if (cc.Intersection.pointInPolygon(nextSelfColliderCircle.position, contactedBarrierPolygonLocalToParentWithinCurrentFrame)) {\n        // Make sure that the player is \"leaving\" the PolygonCollider.\n        return false;  \n      }\n      if (cc.Intersection.polygonCircle(contactedBarrierPolygonLocalToParentWithinCurrentFrame, nextSelfColliderCircle)) {\n        if (null == self.firstContactedEdge) {\n          return false; \n        }\n        if (null != self.firstContactedEdge && self.firstContactedEdge.associatedBarrier != contactedBarrier) {\n          const res = self._calculateTangentialMovementAttrs(nextSelfColliderCircle, contactedBarrier);\n          if (null == res.contactedEdge) {\n            // Otherwise, the current movement is going to transit smoothly onto the next PolygonCollider.\n            return false; \n          }\n        }\n      }\n    }\n\n    return true;\n\n    /*\n     * In a subclass, use \n     * \n     * _canMoveBy(vecToMoveBy) {\n     *   BasePlayer.prototype._canMoveBy.call(this, vecToMoveBy);\n     *   // Customized codes.\n     * }\n     *\n     * Reference http://www.cocos2d-x.org/docs/creator/manual/en/scripting/reference/class.html#override\n     */\n  },\n\n  _calculateTangentialMovementAttrs(currentSelfColliderCircle, contactedBarrier) {\n    /*\n     * Theoretically when the `contactedBarrier` is a convex polygon and the `PlayerCollider` is a circle, there can be only 1 `contactedEdge` for each `contactedBarrier`. Except only for around the corner.\n     *\n     * We should avoid the possibility of players hitting the \"corners of convex polygons\" by map design wherever & whenever possible.\n     *\n     */\n    const self = this;\n    const sDir = self.activeDirection;\n    const currentSelfColliderCircleCentrePos = (currentSelfColliderCircle.position ? currentSelfColliderCircle.position : self.node.position.add(currentSelfColliderCircle.offset));\n    const currentSelfColliderCircleRadius = currentSelfColliderCircle.radius;\n    let contactedEdgeCandidateList = [];\n    let skinDepthThreshold = 0.45*currentSelfColliderCircleRadius;\n    for (let i = 0; i < contactedBarrier.points.length; ++i) {\n      const stPoint = contactedBarrier.points[i].add(contactedBarrier.offset).add(contactedBarrier.node.position);\n      const edPoint = (i == contactedBarrier.points.length - 1 ? contactedBarrier.points[0].add(contactedBarrier.offset).add(contactedBarrier.node.position) : contactedBarrier.points[1 + i].add(contactedBarrier.offset).add(contactedBarrier.node.position));\n      const tmpVSt = stPoint.sub(currentSelfColliderCircleCentrePos);\n      const tmpVEd = edPoint.sub(currentSelfColliderCircleCentrePos);\n      const crossProdScalar = tmpVSt.cross(tmpVEd);\n      if (0 < crossProdScalar) {\n        // If moving parallel along `st <-> ed`, the trajectory of `currentSelfColliderCircleCentrePos` will cut inside the polygon. \n        continue; \n      } \n      const dis = cc.Intersection.pointLineDistance(currentSelfColliderCircleCentrePos, stPoint, edPoint, true); \n      if (dis > currentSelfColliderCircleRadius) continue;\n      if (dis < skinDepthThreshold) continue;\n      contactedEdgeCandidateList.push({\n        st: stPoint, \n        ed: edPoint,\n        associatedBarrier: contactedBarrier,\n      });\n    }\n    let contactedEdge = null;\n    let contactedEdgeDir = null;\n    let largestInnerProdAbs = Number.MIN_VALUE;\n\n    if (0 < contactedEdgeCandidateList.length) {\n      const sDirMag = Math.sqrt(sDir.dx * sDir.dx + sDir.dy * sDir.dy);\n      for (let contactedEdgeCandidate of contactedEdgeCandidateList) {  \n        const tmp = contactedEdgeCandidate.ed.sub(contactedEdgeCandidate.st);\n        const contactedEdgeDirCandidate = {\n          dx: tmp.x,\n          dy: tmp.y,\n        };\n        const contactedEdgeDirCandidateMag = Math.sqrt(contactedEdgeDirCandidate.dx * contactedEdgeDirCandidate.dx + contactedEdgeDirCandidate.dy * contactedEdgeDirCandidate.dy);\n        const innerDotProd = (sDir.dx * contactedEdgeDirCandidate.dx + sDir.dy * contactedEdgeDirCandidate.dy)/(sDirMag * contactedEdgeDirCandidateMag); \n        const innerDotProdThresholdMag = 0.7;\n        if ((0 > innerDotProd && innerDotProd > -innerDotProdThresholdMag) || (0 < innerDotProd && innerDotProd < innerDotProdThresholdMag)) {\n          // Intentionally left blank, in this case the player is trying to escape from the `contactedEdge`.    \n          continue;\n        } else if (innerDotProd > 0) {\n          const abs = Math.abs(innerDotProd);\n          if (abs > largestInnerProdAbs) {\n            contactedEdgeDir = contactedEdgeDirCandidate; \n            contactedEdge = contactedEdgeCandidate;\n          }\n        } else {\n          const abs = Math.abs(innerDotProd);\n          if (abs > largestInnerProdAbs) {\n            contactedEdgeDir = {\n              dx: -contactedEdgeDirCandidate.dx,\n              dy: -contactedEdgeDirCandidate.dy,\n            };\n            contactedEdge = contactedEdgeCandidate; \n          }\n        }\n      }\n    } \n    return {\n      contactedEdgeDir: contactedEdgeDir,\n      contactedEdge: contactedEdge, \n    }; \n  },\n\n  _calculateVecToMoveByWithChosenDir(elapsedTime, sDir) {\n    if (0 == sDir.dx && 0 == sDir.dy) {\n      return cc.v2();\n    }\n    const self = this;\n    const distanceToMove = (self.speed * elapsedTime);\n    const denominator = Math.sqrt(sDir.dx * sDir.dx + sDir.dy * sDir.dy);\n    const unitProjDx = (sDir.dx / denominator);\n    const unitProjDy = (sDir.dy / denominator);\n    return cc.v2(\n      distanceToMove * unitProjDx,\n      distanceToMove * unitProjDy,\n    );\n  },\n\n  _calculateVecToMoveBy(elapsedTime) {\n    const self = this;\n    // Note that `sDir` used in this method MUST BE a copy in RAM.\n    let sDir = {\n      dx: self.activeDirection.dx,\n      dy: self.activeDirection.dy,\n    };\n\n    if (0 == sDir.dx && 0 == sDir.dy) {\n      return cc.v2();\n    }\n\n    self.firstContactedEdge = null; // Reset everytime (temporary algorithm design, might change later).\n    if (0 < self.contactedBarriers.length) {\n      /*\n       * Hardcoded to take care of only the 1st `contactedEdge` of the 1st `contactedBarrier` for now. Each `contactedBarrier` must be \"counterclockwisely convex polygonal\", otherwise sliding doesn't work! \n       *\n       */\n      const contactedBarrier = self.contactedBarriers[0]; \n      const currentSelfColliderCircle = self.node.getComponent(cc.CircleCollider);\n      const res = self._calculateTangentialMovementAttrs(currentSelfColliderCircle, contactedBarrier);\n      if (res.contactedEdge) {\n        self.firstContactedEdge = res.contactedEdge; \n        sDir = res.contactedEdgeDir;\n      }\n    } \n    return self._calculateVecToMoveByWithChosenDir(elapsedTime, sDir);\n  },\n\n  update(dt) {\n    const self = this;\n    const vecToMoveBy = self._calculateVecToMoveBy(dt);\n    if (self._canMoveBy(vecToMoveBy)) {\n      self.node.position = self.computedNewDifferentPosLocalToParentWithinCurrentFrame;\n    }\n  },\n\n  lateUpdate(dt) {\n    const self = this;\n    if (0 != self.activeDirection.dx || 0 != self.activeDirection.dy) {// 如果其中一个为0 就不会改变方向\n      const newScheduledDirectionInLocalCoordinate = self.ctrl.discretizeDirection(self.activeDirection.dx, self.activeDirection.dy, self.eps);\n      self.scheduleNewDirection(newScheduledDirectionInLocalCoordinate, false);\n    }\n    const now = new Date().getTime();\n    self.lastMovedAt = now;\n  },\n\n  onCollisionEnter(other, self) {\n    const playerScriptIns = self.node.getComponent(\"SelfPlayer\");\n    switch (other.node.name) {\n      case \"NPCPlayer\":\n        if (\"NPCPlayer\" != self.node.name) {\n          other.node.getComponent('NPCPlayer').showProfileTrigger();\n        }\n        playerScriptIns._addContactedNPCPlayers(other);\n        break;\n      case \"PolygonBoundaryBarrier\":\n        playerScriptIns._addContactedBarrier(other);\n        break;\n      case \"PolygonBoundaryShelter\":\n        break;\n      case \"PolygonBoundaryShelterZReducer\":\n        playerScriptIns._addCoveringShelterZReducer(other);\n        if (1 == playerScriptIns.coveringShelterZReducers.length) {\n          setLocalZOrder(self.node, 2);\n        }\n        break;\n      default:\n        break;\n    }\n  },\n\n  onCollisionStay(other, self) {\n    // TBD.\n  },\n\n  onCollisionExit(other, self) {\n    const playerScriptIns = self.getComponent(\"SelfPlayer\");\n    switch (other.node.name) {\n      case \"NPCPlayer\":\n        other.node.getComponent('NPCPlayer').hideProfileTrigger();\n        playerScriptIns._removeContactedNPCPlayer(other);\n        break;\n      case \"PolygonBoundaryBarrier\":\n        playerScriptIns._removeContactedBarrier(other);\n        break;\n      case \"PolygonBoundaryShelter\":\n        break;\n      case \"PolygonBoundaryShelterZReducer\":\n        playerScriptIns._removeCoveringShelterZReducer(other);\n        if (0 == playerScriptIns.coveringShelterZReducers.length) {\n          setLocalZOrder(self.node, 5);\n        }\n        break;\n      default:\n        break;\n    }\n  },\n\n  _generateRandomDirection() {\n    return ALL_DISCRETE_DIRECTIONS_CLOCKWISE[Math.floor(Math.random() * ALL_DISCRETE_DIRECTIONS_CLOCKWISE.length)];\n  },\n\n  _generateRandomDirectionExcluding(toExcludeDx, toExcludeDy) {\n    let randomDirectionList = [];\n    let exactIdx = null;\n    for (let ii = 0; ii < ALL_DISCRETE_DIRECTIONS_CLOCKWISE.length; ++ii) {\n      if (toExcludeDx != ALL_DISCRETE_DIRECTIONS_CLOCKWISE[ii].dx || toExcludeDy != ALL_DISCRETE_DIRECTIONS_CLOCKWISE[ii].dy) continue;\n      exactIdx = ii;\n      break;\n    }\n    if (null == exactIdx) {\n      return this._generateRandomDirection();\n    }\n\n    for (let ii = 0; ii < ALL_DISCRETE_DIRECTIONS_CLOCKWISE.length; ++ii) {\n      if (ii == exactIdx || ((ii - 1) % ALL_DISCRETE_DIRECTIONS_CLOCKWISE.length) == exactIdx || ((ii + 1) % ALL_DISCRETE_DIRECTIONS_CLOCKWISE.length) == exactIdx) continue;\n      randomDirectionList.push(ALL_DISCRETE_DIRECTIONS_CLOCKWISE[ii]);\n    }\n    return randomDirectionList[Math.floor(Math.random() * randomDirectionList.length)]\n  },\n\n  updateSpeed(proposedSpeed) {\n    if (0 == proposedSpeed && 0 < this.speed) {\n      this.startFrozenDisplay(); \n    } \n    if (0 < proposedSpeed && 0 == this.speed) {\n      this.stopFrozenDisplay(); \n    } \n    this.speed = proposedSpeed; \n  },\n\n  startFrozenDisplay() {\n    const self =  this;\n    self.attacked = true;\n    self.scheduleNewDirection(self.scheduledDirection, true);\n  },\n\n  stopFrozenDisplay() {\n    const self = this;\n    self.attacked = false;\n    self.scheduleNewDirection(self.scheduledDirection, true);\n  },\n});\n"]}