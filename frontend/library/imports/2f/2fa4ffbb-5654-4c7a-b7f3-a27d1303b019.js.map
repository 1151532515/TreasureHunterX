{"version":3,"sources":["../../../../assets/scripts/assets/scripts/BasePlayer.js"],"names":["module","export","cc","Class","extends","Component","properties","animComp","type","Animation","default","baseSpeed","Float","speed","lastMovedAt","eps","magicLeanLowerBound","magicLeanUpperBound","start","self","contactedControlledPlayers","contactedNPCPlayers","coveringShelterZReducers","computedNewDifferentPosLocalToParentWithinCurrentFrame","actionMangerSingleton","ActionManager","scheduledDirection","dx","dy","activeDirection","onLoad","clips","canvasNode","mapNode","parent","contactedBarriers","joystickInputControllerScriptIns","getComponent","ctrl","node","play","scheduleNewDirection","newScheduledDirection","forceAnimSwitch","clipKey","toString","attacked","attackedClips","clip","warn","log","JSON","stringify","_addCoveringShelterZReducer","comp","coveringShelterZReducer","_id","push","_removeCoveringShelterZReducer","filter","_addContactedBarrier","collider","contactedBarrier","_removeContactedBarrier","_addContactedControlledPlayers","aComp","uuid","_removeContactedControlledPlayer","_addContactedNPCPlayers","_removeContactedNPCPlayer","_canMoveBy","vecToMoveBy","position","add","tileCollisionManager","isOutOfMapNode","currentSelfColliderCircle","CircleCollider","nextSelfColliderCircle","length","mutatedVecToMoveBy","mul","offset","radius","contactedBarrierPolygonLocalToParentWithinCurrentFrame","points","p","Intersection","pointInPolygon","polygonCircle","firstContactedEdge","associatedBarrier","res","_calculateTangentialMovementAttrs","contactedEdge","sDir","currentSelfColliderCircleCentrePos","currentSelfColliderCircleRadius","contactedEdgeCandidateList","skinDepthThreshold","i","stPoint","edPoint","tmpVSt","sub","tmpVEd","crossProdScalar","cross","dis","pointLineDistance","st","ed","contactedEdgeDir","largestInnerProdAbs","Number","MIN_VALUE","sDirMag","Math","sqrt","contactedEdgeCandidate","tmp","contactedEdgeDirCandidate","x","y","contactedEdgeDirCandidateMag","innerDotProd","innerDotProdThresholdMag","abs","_calculateVecToMoveByWithChosenDir","elapsedTime","v2","distanceToMove","denominator","unitProjDx","unitProjDy","_calculateVecToMoveBy","update","dt","lateUpdate","newScheduledDirectionInLocalCoordinate","discretizeDirection","now","Date","getTime","onCollisionEnter","other","playerScriptIns","name","showProfileTrigger","setLocalZOrder","onCollisionStay","onCollisionExit","hideProfileTrigger","_generateRandomDirection","ALL_DISCRETE_DIRECTIONS_CLOCKWISE","floor","random","_generateRandomDirectionExcluding","toExcludeDx","toExcludeDy","randomDirectionList","exactIdx","ii","updateSpeed","proposedSpeed","startFrozenDisplay","stopFrozenDisplay"],"mappings":"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","file":"BasePlayer.js","sourceRoot":"../../../../assets/scripts","sourcesContent":["module.export = cc.Class({\n  extends: cc.Component,\n\n  properties: {\n    animComp: {\n      type: cc.Animation,\n      default: null,\n    },\n    baseSpeed: {\n      type: cc.Float,\n      default: 300,\n    },\n    speed: {\n      type: cc.Float,\n      default: 300\n    },\n    lastMovedAt: {\n      type: cc.Float,\n      default: 0 // In \"GMT milliseconds\"\n    },\n    eps: {\n      default: 0.10,\n      type: cc.Float\n    },\n    magicLeanLowerBound: {\n      default: 0.414, // Tangent of (PI/8).\n      type: cc.Float\n    },\n    magicLeanUpperBound: {\n      default: 2.414, // Tangent of (3*PI/8).\n      type: cc.Float\n    },\n  },\n\n  // LIFE-CYCLE CALLBACKS:\n  start() {\n    const self = this;\n    self.contactedControlledPlayers = [];\n    self.contactedNPCPlayers = [];\n    self.coveringShelterZReducers = [];\n\n    self.computedNewDifferentPosLocalToParentWithinCurrentFrame = null;\n    self.actionMangerSingleton = new cc.ActionManager();\n    self.scheduledDirection = {\n      dx: 0.0,\n      dy: 0.0\n    };\n\n    self.activeDirection = {\n      dx: 0.0,\n      dy: 0.0\n    };\n  },\n\n  onLoad() {\n    const self = this;\n    self.clips = {\n      '01': 'Top',\n      '0-1': 'Bottom',\n      '-20': 'Left',\n      '20': 'Right',\n      '-21': 'TopLeft',\n      '21': 'TopRight',\n      '-2-1': 'BottomLeft',\n      '2-1': 'BottomRight'\n    };\n    const canvasNode = self.mapNode.parent;\n    self.contactedBarriers = [];\n    const joystickInputControllerScriptIns = canvasNode.getComponent(\"TouchEventsManager\");\n    self.ctrl = joystickInputControllerScriptIns;\n    self.animComp = self.node.getComponent(cc.Animation);\n    self.animComp.play();\n  },\n\n  scheduleNewDirection(newScheduledDirection, forceAnimSwitch) {\n    if (!newScheduledDirection) {\n      return;\n    }\n\n    if (forceAnimSwitch || null == this.scheduledDirection || (newScheduledDirection.dx != this.scheduledDirection.dx || newScheduledDirection.dy != this.scheduledDirection.dy)) {\n      this.scheduledDirection = newScheduledDirection;\n      const clipKey = newScheduledDirection.dx.toString() + newScheduledDirection.dy.toString();\n      const clips = (this.attacked ? this.attackedClips : this.clips); \n      let clip = clips[clipKey];\n      if (!clip) {\n        // Keep playing the current anim.\n        if (0 !== newScheduledDirection.dx || 0 !== newScheduledDirection.dy) {\n          cc.warn('Clip for clipKey === ' + clipKey + ' is invalid: ' + clip + '.');\n        }\n      } else {\n        this.animComp.play(clip);\n        if (this.attacked) {\n          cc.log(`Attacked, switching to play clipKey = ${clipKey}, clip == ${clip}, this.activeDirection == ${JSON.stringify(this.activeDirection)}, this.scheduledDirection == ${JSON.stringify(this.scheduledDirection)}.`);\n        }\n      }\n    }\n  },\n\n  _addCoveringShelterZReducer(comp) {\n    const self = this;\n    for (let coveringShelterZReducer of self.coveringShelterZReducers) {\n      if (coveringShelterZReducer._id == comp._id) {\n        return false;\n      }\n    }\n    self.coveringShelterZReducers.push(comp);\n    return true;\n  },\n\n  _removeCoveringShelterZReducer(comp) {\n    const self = this;\n    self.coveringShelterZReducers = self.coveringShelterZReducers.filter((coveringShelterZReducer) => {\n      return coveringShelterZReducer._id != comp._id;\n    });\n    return true;\n  },\n\n  _addContactedBarrier(collider) {\n    const self = this;\n    if (!self.contactedBarriers) {\n      cc.log(\"self.contactedBarriers is null or undefined\" + self.contactedBarriers)\n    }\n    for (let contactedBarrier of self.contactedBarriers) {\n      if (contactedBarrier._id == collider._id) {\n        return false;\n      }\n    }\n    self.contactedBarriers.push(collider);\n    return true;\n  },\n\n  _removeContactedBarrier(collider) {\n    const self = this;\n    self.contactedBarriers = self.contactedBarriers.filter((contactedBarrier) => {\n      return contactedBarrier._id != collider._id;\n    });\n    return true;\n  },\n\n  _addContactedControlledPlayers(comp) {\n    const self = this;\n    for (let aComp of self.contactedControlledPlayers) {\n      if (aComp.uuid == comp.uuid) {\n        return false;\n      }\n    }\n    self.contactedControlledPlayers.push(comp);\n    return true;\n  },\n\n  _removeContactedControlledPlayer(comp) {\n    const self = this;\n    self.contactedControlledPlayers = self.contactedControlledPlayers.filter((aComp) => {\n      return aComp.uuid != comp.uuid;\n    });\n    return true;\n  },\n\n  _addContactedNPCPlayers(comp) {\n    const self = this;\n    for (let aComp of self.contactedNPCPlayers) {\n      if (aComp.uuid == comp.uuid) {\n        return false;\n      }\n    }\n    self.contactedNPCPlayers.push(comp);\n    return true;\n  },\n\n  _removeContactedNPCPlayer(comp) {\n    const self = this;\n    self.contactedNPCPlayers = self.contactedNPCPlayers.filter((aComp) => {\n      return aComp.uuid != comp.uuid;\n    });\n    return true;\n  },\n\n  _canMoveBy(vecToMoveBy) {\n    const self = this;\n    const computedNewDifferentPosLocalToParentWithinCurrentFrame = self.node.position.add(vecToMoveBy);\n    self.computedNewDifferentPosLocalToParentWithinCurrentFrame = computedNewDifferentPosLocalToParentWithinCurrentFrame;\n\n    if (tileCollisionManager.isOutOfMapNode(self.mapNode, computedNewDifferentPosLocalToParentWithinCurrentFrame)) {\n      return false;\n    }\n\n    const currentSelfColliderCircle = self.node.getComponent(cc.CircleCollider);\n    let nextSelfColliderCircle = null;\n    if (0 < self.contactedBarriers.length) {\n      /* To avoid unexpected buckling. */\n      const mutatedVecToMoveBy = vecToMoveBy.mul(5); // To help it escape the engaged `contactedBarriers`.\n      nextSelfColliderCircle = {\n        position: self.node.position.add(mutatedVecToMoveBy).add(currentSelfColliderCircle.offset),\n        radius: currentSelfColliderCircle.radius,\n      };\n    } else {\n      nextSelfColliderCircle = {\n        position: computedNewDifferentPosLocalToParentWithinCurrentFrame.add(currentSelfColliderCircle.offset),\n        radius: currentSelfColliderCircle.radius,\n      };\n    }\n\n    for (let contactedBarrier of self.contactedBarriers) {\n      let contactedBarrierPolygonLocalToParentWithinCurrentFrame = [];\n      for (let p of contactedBarrier.points) {\n        contactedBarrierPolygonLocalToParentWithinCurrentFrame.push(contactedBarrier.node.position.add(p));\n      }\n      if (cc.Intersection.pointInPolygon(nextSelfColliderCircle.position, contactedBarrierPolygonLocalToParentWithinCurrentFrame)) {\n        // Make sure that the player is \"leaving\" the PolygonCollider.\n        return false;  \n      }\n      if (cc.Intersection.polygonCircle(contactedBarrierPolygonLocalToParentWithinCurrentFrame, nextSelfColliderCircle)) {\n        if (null == self.firstContactedEdge) {\n          return false; \n        }\n        if (null != self.firstContactedEdge && self.firstContactedEdge.associatedBarrier != contactedBarrier) {\n          const res = self._calculateTangentialMovementAttrs(nextSelfColliderCircle, contactedBarrier);\n          if (null == res.contactedEdge) {\n            // Otherwise, the current movement is going to transit smoothly onto the next PolygonCollider.\n            return false; \n          }\n        }\n      }\n    }\n\n    return true;\n\n    /*\n     * In a subclass, use \n     * \n     * _canMoveBy(vecToMoveBy) {\n     *   BasePlayer.prototype._canMoveBy.call(this, vecToMoveBy);\n     *   // Customized codes.\n     * }\n     *\n     * Reference http://www.cocos2d-x.org/docs/creator/manual/en/scripting/reference/class.html#override\n     */\n  },\n\n  _calculateTangentialMovementAttrs(currentSelfColliderCircle, contactedBarrier) {\n    /*\n     * Theoretically when the `contactedBarrier` is a convex polygon and the `PlayerCollider` is a circle, there can be only 1 `contactedEdge` for each `contactedBarrier`. Except only for around the corner.\n     *\n     * We should avoid the possibility of players hitting the \"corners of convex polygons\" by map design wherever & whenever possible.\n     *\n     */\n    const self = this;\n    const sDir = self.activeDirection;\n    const currentSelfColliderCircleCentrePos = (currentSelfColliderCircle.position ? currentSelfColliderCircle.position : self.node.position.add(currentSelfColliderCircle.offset));\n    const currentSelfColliderCircleRadius = currentSelfColliderCircle.radius;\n    let contactedEdgeCandidateList = [];\n    let skinDepthThreshold = 0.45*currentSelfColliderCircleRadius;\n    for (let i = 0; i < contactedBarrier.points.length; ++i) {\n      const stPoint = contactedBarrier.points[i].add(contactedBarrier.offset).add(contactedBarrier.node.position);\n      const edPoint = (i == contactedBarrier.points.length - 1 ? contactedBarrier.points[0].add(contactedBarrier.offset).add(contactedBarrier.node.position) : contactedBarrier.points[1 + i].add(contactedBarrier.offset).add(contactedBarrier.node.position));\n      const tmpVSt = stPoint.sub(currentSelfColliderCircleCentrePos);\n      const tmpVEd = edPoint.sub(currentSelfColliderCircleCentrePos);\n      const crossProdScalar = tmpVSt.cross(tmpVEd);\n      if (0 < crossProdScalar) {\n        // If moving parallel along `st <-> ed`, the trajectory of `currentSelfColliderCircleCentrePos` will cut inside the polygon. \n        continue; \n      } \n      const dis = cc.Intersection.pointLineDistance(currentSelfColliderCircleCentrePos, stPoint, edPoint, true); \n      if (dis > currentSelfColliderCircleRadius) continue;\n      if (dis < skinDepthThreshold) continue;\n      contactedEdgeCandidateList.push({\n        st: stPoint, \n        ed: edPoint,\n        associatedBarrier: contactedBarrier,\n      });\n    }\n    let contactedEdge = null;\n    let contactedEdgeDir = null;\n    let largestInnerProdAbs = Number.MIN_VALUE;\n\n    if (0 < contactedEdgeCandidateList.length) {\n      const sDirMag = Math.sqrt(sDir.dx * sDir.dx + sDir.dy * sDir.dy);\n      for (let contactedEdgeCandidate of contactedEdgeCandidateList) {  \n        const tmp = contactedEdgeCandidate.ed.sub(contactedEdgeCandidate.st);\n        const contactedEdgeDirCandidate = {\n          dx: tmp.x,\n          dy: tmp.y,\n        };\n        const contactedEdgeDirCandidateMag = Math.sqrt(contactedEdgeDirCandidate.dx * contactedEdgeDirCandidate.dx + contactedEdgeDirCandidate.dy * contactedEdgeDirCandidate.dy);\n        const innerDotProd = (sDir.dx * contactedEdgeDirCandidate.dx + sDir.dy * contactedEdgeDirCandidate.dy)/(sDirMag * contactedEdgeDirCandidateMag); \n        const innerDotProdThresholdMag = 0.7;\n        if ((0 > innerDotProd && innerDotProd > -innerDotProdThresholdMag) || (0 < innerDotProd && innerDotProd < innerDotProdThresholdMag)) {\n          // Intentionally left blank, in this case the player is trying to escape from the `contactedEdge`.    \n          continue;\n        } else if (innerDotProd > 0) {\n          const abs = Math.abs(innerDotProd);\n          if (abs > largestInnerProdAbs) {\n            contactedEdgeDir = contactedEdgeDirCandidate; \n            contactedEdge = contactedEdgeCandidate;\n          }\n        } else {\n          const abs = Math.abs(innerDotProd);\n          if (abs > largestInnerProdAbs) {\n            contactedEdgeDir = {\n              dx: -contactedEdgeDirCandidate.dx,\n              dy: -contactedEdgeDirCandidate.dy,\n            };\n            contactedEdge = contactedEdgeCandidate; \n          }\n        }\n      }\n    } \n    return {\n      contactedEdgeDir: contactedEdgeDir,\n      contactedEdge: contactedEdge, \n    }; \n  },\n\n  _calculateVecToMoveByWithChosenDir(elapsedTime, sDir) {\n    if (0 == sDir.dx && 0 == sDir.dy) {\n      return cc.v2();\n    }\n    const self = this;\n    const distanceToMove = (self.speed * elapsedTime);\n    const denominator = Math.sqrt(sDir.dx * sDir.dx + sDir.dy * sDir.dy);\n    const unitProjDx = (sDir.dx / denominator);\n    const unitProjDy = (sDir.dy / denominator);\n    return cc.v2(\n      distanceToMove * unitProjDx,\n      distanceToMove * unitProjDy,\n    );\n  },\n\n  _calculateVecToMoveBy(elapsedTime) {\n    const self = this;\n    // Note that `sDir` used in this method MUST BE a copy in RAM.\n    let sDir = {\n      dx: self.activeDirection.dx,\n      dy: self.activeDirection.dy,\n    };\n\n    if (0 == sDir.dx && 0 == sDir.dy) {\n      return cc.v2();\n    }\n\n    self.firstContactedEdge = null; // Reset everytime (temporary algorithm design, might change later).\n    if (0 < self.contactedBarriers.length) {\n      /*\n       * Hardcoded to take care of only the 1st `contactedEdge` of the 1st `contactedBarrier` for now. Each `contactedBarrier` must be \"counterclockwisely convex polygonal\", otherwise sliding doesn't work! \n       *\n       */\n      const contactedBarrier = self.contactedBarriers[0]; \n      const currentSelfColliderCircle = self.node.getComponent(cc.CircleCollider);\n      const res = self._calculateTangentialMovementAttrs(currentSelfColliderCircle, contactedBarrier);\n      if (res.contactedEdge) {\n        self.firstContactedEdge = res.contactedEdge; \n        sDir = res.contactedEdgeDir;\n      }\n    } \n    return self._calculateVecToMoveByWithChosenDir(elapsedTime, sDir);\n  },\n\n  update(dt) {\n    const self = this;\n    const vecToMoveBy = self._calculateVecToMoveBy(dt);\n    if (self._canMoveBy(vecToMoveBy)) {\n      self.node.position = self.computedNewDifferentPosLocalToParentWithinCurrentFrame;\n    }\n  },\n\n  lateUpdate(dt) {\n    const self = this;\n    if (0 != self.activeDirection.dx || 0 != self.activeDirection.dy) {// 如果其中一个为0 就不会改变方向\n      const newScheduledDirectionInLocalCoordinate = self.ctrl.discretizeDirection(self.activeDirection.dx, self.activeDirection.dy, self.eps);\n      self.scheduleNewDirection(newScheduledDirectionInLocalCoordinate, false);\n    }\n    const now = new Date().getTime();\n    self.lastMovedAt = now;\n  },\n\n  onCollisionEnter(other, self) {\n    const playerScriptIns = self.node.getComponent(\"SelfPlayer\");\n    switch (other.node.name) {\n      case \"NPCPlayer\":\n        if (\"NPCPlayer\" != self.node.name) {\n          other.node.getComponent('NPCPlayer').showProfileTrigger();\n        }\n        playerScriptIns._addContactedNPCPlayers(other);\n        break;\n      case \"PolygonBoundaryBarrier\":\n        playerScriptIns._addContactedBarrier(other);\n        break;\n      case \"PolygonBoundaryShelter\":\n        break;\n      case \"PolygonBoundaryShelterZReducer\":\n        playerScriptIns._addCoveringShelterZReducer(other);\n        if (1 == playerScriptIns.coveringShelterZReducers.length) {\n          setLocalZOrder(self.node, 2);\n        }\n        break;\n      default:\n        break;\n    }\n  },\n\n  onCollisionStay(other, self) {\n    // TBD.\n  },\n\n  onCollisionExit(other, self) {\n    const playerScriptIns = self.getComponent(\"SelfPlayer\");\n    switch (other.node.name) {\n      case \"NPCPlayer\":\n        other.node.getComponent('NPCPlayer').hideProfileTrigger();\n        playerScriptIns._removeContactedNPCPlayer(other);\n        break;\n      case \"PolygonBoundaryBarrier\":\n        playerScriptIns._removeContactedBarrier(other);\n        break;\n      case \"PolygonBoundaryShelter\":\n        break;\n      case \"PolygonBoundaryShelterZReducer\":\n        playerScriptIns._removeCoveringShelterZReducer(other);\n        if (0 == playerScriptIns.coveringShelterZReducers.length) {\n          setLocalZOrder(self.node, 5);\n        }\n        break;\n      default:\n        break;\n    }\n  },\n\n  _generateRandomDirection() {\n    return ALL_DISCRETE_DIRECTIONS_CLOCKWISE[Math.floor(Math.random() * ALL_DISCRETE_DIRECTIONS_CLOCKWISE.length)];\n  },\n\n  _generateRandomDirectionExcluding(toExcludeDx, toExcludeDy) {\n    let randomDirectionList = [];\n    let exactIdx = null;\n    for (let ii = 0; ii < ALL_DISCRETE_DIRECTIONS_CLOCKWISE.length; ++ii) {\n      if (toExcludeDx != ALL_DISCRETE_DIRECTIONS_CLOCKWISE[ii].dx || toExcludeDy != ALL_DISCRETE_DIRECTIONS_CLOCKWISE[ii].dy) continue;\n      exactIdx = ii;\n      break;\n    }\n    if (null == exactIdx) {\n      return this._generateRandomDirection();\n    }\n\n    for (let ii = 0; ii < ALL_DISCRETE_DIRECTIONS_CLOCKWISE.length; ++ii) {\n      if (ii == exactIdx || ((ii - 1) % ALL_DISCRETE_DIRECTIONS_CLOCKWISE.length) == exactIdx || ((ii + 1) % ALL_DISCRETE_DIRECTIONS_CLOCKWISE.length) == exactIdx) continue;\n      randomDirectionList.push(ALL_DISCRETE_DIRECTIONS_CLOCKWISE[ii]);\n    }\n    return randomDirectionList[Math.floor(Math.random() * randomDirectionList.length)]\n  },\n\n  updateSpeed(proposedSpeed) {\n    if (0 == proposedSpeed && 0 < this.speed) {\n      this.startFrozenDisplay(); \n    } \n    if (0 < proposedSpeed && 0 == this.speed) {\n      this.stopFrozenDisplay(); \n    } \n    this.speed = proposedSpeed; \n  },\n\n  startFrozenDisplay() {\n    const self =  this;\n    self.attacked = true;\n    self.scheduleNewDirection(self.scheduledDirection, true);\n  },\n\n  stopFrozenDisplay() {\n    const self = this;\n    self.attacked = false;\n    self.scheduleNewDirection(self.scheduledDirection, true);\n  },\n});\n"]}