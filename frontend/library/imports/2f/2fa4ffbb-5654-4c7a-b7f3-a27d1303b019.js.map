{"version":3,"sources":["..\\..\\..\\..\\assets\\scripts/assets\\scripts\\BasePlayer.js"],"names":["module","export","cc","Class","extends","Component","properties","animComp","type","Animation","default","baseSpeed","Float","speed","lastMovedAt","eps","magicLeanLowerBound","magicLeanUpperBound","start","self","contactedControlledPlayers","contactedNPCPlayers","coveringShelterZReducers","computedNewDifferentPosLocalToParentWithinCurrentFrame","actionMangerSingleton","ActionManager","scheduledDirection","dx","dy","activeDirection","onLoad","canvasNode","mapNode","parent","contactedBarriers","joystickInputControllerScriptIns","getComponent","ctrl","node","play","scheduleNewDirection","newScheduledDirection","forceAnimSwitch","clipKey","toString","clip","clips","console","warn","_addCoveringShelterZReducer","comp","coveringShelterZReducer","_id","push","_removeCoveringShelterZReducer","filter","_addContactedBarrier","collider","log","contactedBarrier","_removeContactedBarrier","_addContactedControlledPlayers","aComp","uuid","_removeContactedControlledPlayer","_addContactedNPCPlayers","_removeContactedNPCPlayer","_canMoveBy","vecToMoveBy","position","add","tileCollisionManager","isOutOfMapNode","currentSelfColliderCircle","CircleCollider","nextSelfColliderCircle","length","mutatedVecToMoveBy","mul","offset","radius","contactedBarrierPolygonLocalToParentWithinCurrentFrame","points","p","Intersection","pointInPolygon","polygonCircle","firstContactedEdge","associatedBarrier","res","_calculateTangentialMovementAttrs","contactedEdge","sDir","currentSelfColliderCircleCentrePos","currentSelfColliderCircleRadius","contactedEdgeCandidateList","skinDepthThreshold","i","stPoint","edPoint","tmpVSt","sub","tmpVEd","crossProdScalar","cross","dis","pointLineDistance","st","ed","contactedEdgeDir","largestInnerProdAbs","Number","MIN_VALUE","sDirMag","Math","sqrt","contactedEdgeCandidate","tmp","contactedEdgeDirCandidate","x","y","contactedEdgeDirCandidateMag","innerDotProd","innerDotProdThresholdMag","abs","_calculateVecToMoveByWithChosenDir","elapsedTime","v2","distanceToMove","denominator","unitProjDx","unitProjDy","_calculateVecToMoveBy","update","dt","lateUpdate","newScheduledDirectionInLocalCoordinate","discretizeDirection","now","Date","getTime","onCollisionEnter","other","playerScriptIns","name","showProfileTrigger","setLocalZOrder","onCollisionStay","onCollisionExit","hideProfileTrigger","_generateRandomDirection","ALL_DISCRETE_DIRECTIONS_CLOCKWISE","floor","random","_generateRandomDirectionExcluding","toExcludeDx","toExcludeDy","randomDirectionList","exactIdx","ii","updateSpeed","proposedSpeed","startFrozenDisplay","stopFrozenDisplay","opacity"],"mappings":"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","file":"BasePlayer.js","sourceRoot":"..\\..\\..\\..\\assets\\scripts","sourcesContent":["module.export = cc.Class({\r\n  extends: cc.Component,\r\n\r\n  properties: {\r\n    animComp: {\r\n      type: cc.Animation,\r\n      default: null,\r\n    },\r\n    baseSpeed: {\r\n      type: cc.Float,\r\n      default: 300,\r\n    },\r\n    speed: {\r\n      type: cc.Float,\r\n      default: 300\r\n    },\r\n    lastMovedAt: {\r\n      type: cc.Float,\r\n      default: 0 // In \"GMT milliseconds\"\r\n    },\r\n    eps: {\r\n      default: 0.10,\r\n      type: cc.Float\r\n    },\r\n    magicLeanLowerBound: {\r\n      default: 0.414, // Tangent of (PI/8).\r\n      type: cc.Float\r\n    },\r\n    magicLeanUpperBound: {\r\n      default: 2.414, // Tangent of (3*PI/8).\r\n      type: cc.Float\r\n    },\r\n  },\r\n\r\n  // LIFE-CYCLE CALLBACKS:\r\n  start() {\r\n    const self = this;\r\n    self.contactedControlledPlayers = [];\r\n    self.contactedNPCPlayers = [];\r\n    self.coveringShelterZReducers = [];\r\n\r\n    self.computedNewDifferentPosLocalToParentWithinCurrentFrame = null;\r\n    self.actionMangerSingleton = new cc.ActionManager();\r\n    self.scheduledDirection = {\r\n      dx: 0.0,\r\n      dy: 0.0\r\n    };\r\n\r\n    self.activeDirection = {\r\n      dx: 0.0,\r\n      dy: 0.0\r\n    };\r\n  },\r\n\r\n  onLoad() {\r\n    const self = this;\r\n    const canvasNode = self.mapNode.parent;\r\n    self.contactedBarriers = [];\r\n    const joystickInputControllerScriptIns = canvasNode.getComponent(\"TouchEventsManager\");\r\n    self.ctrl = joystickInputControllerScriptIns;\r\n    self.animComp = self.node.getComponent(cc.Animation);\r\n    self.animComp.play();\r\n  },\r\n\r\n  scheduleNewDirection(newScheduledDirection, forceAnimSwitch) {\r\n    if (!newScheduledDirection) {\r\n      return;\r\n    }\r\n    if (forceAnimSwitch || null == this.scheduledDirection || (newScheduledDirection.dx != this.scheduledDirection.dx || newScheduledDirection.dy != this.scheduledDirection.dy)) {\r\n      this.scheduledDirection = newScheduledDirection;\r\n      const clipKey = newScheduledDirection.dx.toString() + newScheduledDirection.dy.toString()\r\n      let clip = this.clips[clipKey];\r\n      if (!clip) {\r\n        // Keep playing the current anim.\r\n        if (0 !== newScheduledDirection.dx || 0 !== newScheduledDirection.dy) {\r\n          console.warn('Clip for clipKey === ' + clipKey + ' is invalid: ' + clip + '.');\r\n        }\r\n      } else {\r\n        this.animComp.play(clip);\r\n      }\r\n    }\r\n  },\r\n\r\n  _addCoveringShelterZReducer(comp) {\r\n    const self = this;\r\n    for (let coveringShelterZReducer of self.coveringShelterZReducers) {\r\n      if (coveringShelterZReducer._id == comp._id) {\r\n        return false;\r\n      }\r\n    }\r\n    self.coveringShelterZReducers.push(comp);\r\n    return true;\r\n  },\r\n\r\n  _removeCoveringShelterZReducer(comp) {\r\n    const self = this;\r\n    self.coveringShelterZReducers = self.coveringShelterZReducers.filter((coveringShelterZReducer) => {\r\n      return coveringShelterZReducer._id != comp._id;\r\n    });\r\n    return true;\r\n  },\r\n\r\n  _addContactedBarrier(collider) {\r\n    const self = this;\r\n    if (!self.contactedBarriers) {\r\n      cc.log(\"self.contactedBarriers is null or undefined\" + self.contactedBarriers)\r\n    }\r\n    for (let contactedBarrier of self.contactedBarriers) {\r\n      if (contactedBarrier._id == collider._id) {\r\n        return false;\r\n      }\r\n    }\r\n    self.contactedBarriers.push(collider);\r\n    return true;\r\n  },\r\n\r\n  _removeContactedBarrier(collider) {\r\n    const self = this;\r\n    self.contactedBarriers = self.contactedBarriers.filter((contactedBarrier) => {\r\n      return contactedBarrier._id != collider._id;\r\n    });\r\n    return true;\r\n  },\r\n\r\n  _addContactedControlledPlayers(comp) {\r\n    const self = this;\r\n    for (let aComp of self.contactedControlledPlayers) {\r\n      if (aComp.uuid == comp.uuid) {\r\n        return false;\r\n      }\r\n    }\r\n    self.contactedControlledPlayers.push(comp);\r\n    return true;\r\n  },\r\n\r\n  _removeContactedControlledPlayer(comp) {\r\n    const self = this;\r\n    self.contactedControlledPlayers = self.contactedControlledPlayers.filter((aComp) => {\r\n      return aComp.uuid != comp.uuid;\r\n    });\r\n    return true;\r\n  },\r\n\r\n  _addContactedNPCPlayers(comp) {\r\n    const self = this;\r\n    for (let aComp of self.contactedNPCPlayers) {\r\n      if (aComp.uuid == comp.uuid) {\r\n        return false;\r\n      }\r\n    }\r\n    self.contactedNPCPlayers.push(comp);\r\n    return true;\r\n  },\r\n\r\n  _removeContactedNPCPlayer(comp) {\r\n    const self = this;\r\n    self.contactedNPCPlayers = self.contactedNPCPlayers.filter((aComp) => {\r\n      return aComp.uuid != comp.uuid;\r\n    });\r\n    return true;\r\n  },\r\n\r\n  _canMoveBy(vecToMoveBy) {\r\n    const self = this;\r\n    const computedNewDifferentPosLocalToParentWithinCurrentFrame = self.node.position.add(vecToMoveBy);\r\n    self.computedNewDifferentPosLocalToParentWithinCurrentFrame = computedNewDifferentPosLocalToParentWithinCurrentFrame;\r\n\r\n    if (tileCollisionManager.isOutOfMapNode(self.mapNode, computedNewDifferentPosLocalToParentWithinCurrentFrame)) {\r\n      return false;\r\n    }\r\n\r\n    const currentSelfColliderCircle = self.node.getComponent(cc.CircleCollider);\r\n    let nextSelfColliderCircle = null;\r\n    if (0 < self.contactedBarriers.length) {\r\n      /* To avoid unexpected buckling. */\r\n      const mutatedVecToMoveBy = vecToMoveBy.mul(5); // To help it escape the engaged `contactedBarriers`.\r\n      nextSelfColliderCircle = {\r\n        position: self.node.position.add(mutatedVecToMoveBy).add(currentSelfColliderCircle.offset),\r\n        radius: currentSelfColliderCircle.radius,\r\n      };\r\n    } else {\r\n      nextSelfColliderCircle = {\r\n        position: computedNewDifferentPosLocalToParentWithinCurrentFrame.add(currentSelfColliderCircle.offset),\r\n        radius: currentSelfColliderCircle.radius,\r\n      };\r\n    }\r\n\r\n    for (let contactedBarrier of self.contactedBarriers) {\r\n      let contactedBarrierPolygonLocalToParentWithinCurrentFrame = [];\r\n      for (let p of contactedBarrier.points) {\r\n        contactedBarrierPolygonLocalToParentWithinCurrentFrame.push(contactedBarrier.node.position.add(p));\r\n      }\r\n      if (cc.Intersection.pointInPolygon(nextSelfColliderCircle.position, contactedBarrierPolygonLocalToParentWithinCurrentFrame)) {\r\n        // Make sure that the player is \"leaving\" the PolygonCollider.\r\n        return false;  \r\n      }\r\n      if (cc.Intersection.polygonCircle(contactedBarrierPolygonLocalToParentWithinCurrentFrame, nextSelfColliderCircle)) {\r\n        if (null == self.firstContactedEdge) {\r\n          return false; \r\n        }\r\n        if (null != self.firstContactedEdge && self.firstContactedEdge.associatedBarrier != contactedBarrier) {\r\n          const res = self._calculateTangentialMovementAttrs(nextSelfColliderCircle, contactedBarrier);\r\n          if (null == res.contactedEdge) {\r\n            // Otherwise, the current movement is going to transit smoothly onto the next PolygonCollider.\r\n            return false; \r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n\r\n    /*\r\n     * In a subclass, use \r\n     * \r\n     * _canMoveBy(vecToMoveBy) {\r\n     *   BasePlayer.prototype._canMoveBy.call(this, vecToMoveBy);\r\n     *   // Customized codes.\r\n     * }\r\n     *\r\n     * Reference http://www.cocos2d-x.org/docs/creator/manual/en/scripting/reference/class.html#override\r\n     */\r\n  },\r\n\r\n  _calculateTangentialMovementAttrs(currentSelfColliderCircle, contactedBarrier) {\r\n    /*\r\n     * Theoretically when the `contactedBarrier` is a convex polygon and the `PlayerCollider` is a circle, there can be only 1 `contactedEdge` for each `contactedBarrier`. Except only for around the corner.\r\n     *\r\n     * We should avoid the possibility of players hitting the \"corners of convex polygons\" by map design wherever & whenever possible.\r\n     *\r\n     */\r\n    const self = this;\r\n    const sDir = self.activeDirection;\r\n    const currentSelfColliderCircleCentrePos = (currentSelfColliderCircle.position ? currentSelfColliderCircle.position : self.node.position.add(currentSelfColliderCircle.offset));\r\n    const currentSelfColliderCircleRadius = currentSelfColliderCircle.radius;\r\n    let contactedEdgeCandidateList = [];\r\n    let skinDepthThreshold = 0.45*currentSelfColliderCircleRadius;\r\n    for (let i = 0; i < contactedBarrier.points.length; ++i) {\r\n      const stPoint = contactedBarrier.points[i].add(contactedBarrier.offset).add(contactedBarrier.node.position);\r\n      const edPoint = (i == contactedBarrier.points.length - 1 ? contactedBarrier.points[0].add(contactedBarrier.offset).add(contactedBarrier.node.position) : contactedBarrier.points[1 + i].add(contactedBarrier.offset).add(contactedBarrier.node.position));\r\n      const tmpVSt = stPoint.sub(currentSelfColliderCircleCentrePos);\r\n      const tmpVEd = edPoint.sub(currentSelfColliderCircleCentrePos);\r\n      const crossProdScalar = tmpVSt.cross(tmpVEd);\r\n      if (0 < crossProdScalar) {\r\n        // If moving parallel along `st <-> ed`, the trajectory of `currentSelfColliderCircleCentrePos` will cut inside the polygon. \r\n        continue; \r\n      } \r\n      const dis = cc.Intersection.pointLineDistance(currentSelfColliderCircleCentrePos, stPoint, edPoint, true); \r\n      if (dis > currentSelfColliderCircleRadius) continue;\r\n      if (dis < skinDepthThreshold) continue;\r\n      contactedEdgeCandidateList.push({\r\n        st: stPoint, \r\n        ed: edPoint,\r\n        associatedBarrier: contactedBarrier,\r\n      });\r\n    }\r\n    let contactedEdge = null;\r\n    let contactedEdgeDir = null;\r\n    let largestInnerProdAbs = Number.MIN_VALUE;\r\n\r\n    if (0 < contactedEdgeCandidateList.length) {\r\n      const sDirMag = Math.sqrt(sDir.dx * sDir.dx + sDir.dy * sDir.dy);\r\n      for (let contactedEdgeCandidate of contactedEdgeCandidateList) {  \r\n        const tmp = contactedEdgeCandidate.ed.sub(contactedEdgeCandidate.st);\r\n        const contactedEdgeDirCandidate = {\r\n          dx: tmp.x,\r\n          dy: tmp.y,\r\n        };\r\n        const contactedEdgeDirCandidateMag = Math.sqrt(contactedEdgeDirCandidate.dx * contactedEdgeDirCandidate.dx + contactedEdgeDirCandidate.dy * contactedEdgeDirCandidate.dy);\r\n        const innerDotProd = (sDir.dx * contactedEdgeDirCandidate.dx + sDir.dy * contactedEdgeDirCandidate.dy)/(sDirMag * contactedEdgeDirCandidateMag); \r\n        const innerDotProdThresholdMag = 0.7;\r\n        if ((0 > innerDotProd && innerDotProd > -innerDotProdThresholdMag) || (0 < innerDotProd && innerDotProd < innerDotProdThresholdMag)) {\r\n          // Intentionally left blank, in this case the player is trying to escape from the `contactedEdge`.    \r\n          continue;\r\n        } else if (innerDotProd > 0) {\r\n          const abs = Math.abs(innerDotProd);\r\n          if (abs > largestInnerProdAbs) {\r\n            contactedEdgeDir = contactedEdgeDirCandidate; \r\n            contactedEdge = contactedEdgeCandidate;\r\n          }\r\n        } else {\r\n          const abs = Math.abs(innerDotProd);\r\n          if (abs > largestInnerProdAbs) {\r\n            contactedEdgeDir = {\r\n              dx: -contactedEdgeDirCandidate.dx,\r\n              dy: -contactedEdgeDirCandidate.dy,\r\n            };\r\n            contactedEdge = contactedEdgeCandidate; \r\n          }\r\n        }\r\n      }\r\n    } \r\n    return {\r\n      contactedEdgeDir: contactedEdgeDir,\r\n      contactedEdge: contactedEdge, \r\n    }; \r\n  },\r\n\r\n  _calculateVecToMoveByWithChosenDir(elapsedTime, sDir) {\r\n    if (0 == sDir.dx && 0 == sDir.dy) {\r\n      return cc.v2();\r\n    }\r\n    const self = this;\r\n    const distanceToMove = (self.speed * elapsedTime);\r\n    const denominator = Math.sqrt(sDir.dx * sDir.dx + sDir.dy * sDir.dy);\r\n    const unitProjDx = (sDir.dx / denominator);\r\n    const unitProjDy = (sDir.dy / denominator);\r\n    return cc.v2(\r\n      distanceToMove * unitProjDx,\r\n      distanceToMove * unitProjDy,\r\n    );\r\n  },\r\n\r\n  _calculateVecToMoveBy(elapsedTime) {\r\n    const self = this;\r\n    // Note that `sDir` used in this method MUST BE a copy in RAM.\r\n    let sDir = {\r\n      dx: self.activeDirection.dx,\r\n      dy: self.activeDirection.dy,\r\n    };\r\n\r\n    if (0 == sDir.dx && 0 == sDir.dy) {\r\n      return cc.v2();\r\n    }\r\n\r\n    self.firstContactedEdge = null; // Reset everytime (temporary algorithm design, might change later).\r\n    if (0 < self.contactedBarriers.length) {\r\n      /*\r\n       * Hardcoded to take care of only the 1st `contactedEdge` of the 1st `contactedBarrier` for now. Each `contactedBarrier` must be \"counterclockwisely convex polygonal\", otherwise sliding doesn't work! \r\n       *\r\n       */\r\n      const contactedBarrier = self.contactedBarriers[0]; \r\n      const currentSelfColliderCircle = self.node.getComponent(cc.CircleCollider);\r\n      const res = self._calculateTangentialMovementAttrs(currentSelfColliderCircle, contactedBarrier);\r\n      if (res.contactedEdge) {\r\n        self.firstContactedEdge = res.contactedEdge; \r\n        sDir = res.contactedEdgeDir;\r\n      }\r\n    } \r\n    return self._calculateVecToMoveByWithChosenDir(elapsedTime, sDir);\r\n  },\r\n\r\n  update(dt) {\r\n    const self = this;\r\n    const vecToMoveBy = self._calculateVecToMoveBy(dt);\r\n    if (self._canMoveBy(vecToMoveBy)) {\r\n      self.node.position = self.computedNewDifferentPosLocalToParentWithinCurrentFrame;\r\n    }\r\n  },\r\n\r\n  lateUpdate(dt) {\r\n    const self = this;\r\n    if (0 != self.activeDirection.dx || 0 != self.activeDirection.dy) {\r\n      const newScheduledDirectionInLocalCoordinate = self.ctrl.discretizeDirection(self.activeDirection.dx, self.activeDirection.dy, self.eps);\r\n      self.scheduleNewDirection(newScheduledDirectionInLocalCoordinate);\r\n    }\r\n    const now = new Date().getTime();\r\n    self.lastMovedAt = now;\r\n  },\r\n\r\n  onCollisionEnter(other, self) {\r\n    const playerScriptIns = self.getComponent(self.node.name);\r\n    switch (other.node.name) {\r\n      case \"NPCPlayer\":\r\n        if (\"NPCPlayer\" != self.node.name) {\r\n          other.node.getComponent('NPCPlayer').showProfileTrigger();\r\n        }\r\n        playerScriptIns._addContactedNPCPlayers(other);\r\n        break;\r\n      case \"PolygonBoundaryBarrier\":\r\n        playerScriptIns._addContactedBarrier(other);\r\n        break;\r\n      case \"PolygonBoundaryShelter\":\r\n        break;\r\n      case \"PolygonBoundaryShelterZReducer\":\r\n        playerScriptIns._addCoveringShelterZReducer(other);\r\n        if (1 == playerScriptIns.coveringShelterZReducers.length) {\r\n          setLocalZOrder(self.node, 2);\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  },\r\n\r\n  onCollisionStay(other, self) {\r\n    // TBD.\r\n  },\r\n\r\n  onCollisionExit(other, self) {\r\n    const playerScriptIns = self.getComponent(self.node.name);\r\n    switch (other.node.name) {\r\n      case \"NPCPlayer\":\r\n        other.node.getComponent('NPCPlayer').hideProfileTrigger();\r\n        playerScriptIns._removeContactedNPCPlayer(other);\r\n        break;\r\n      case \"PolygonBoundaryBarrier\":\r\n        playerScriptIns._removeContactedBarrier(other);\r\n        break;\r\n      case \"PolygonBoundaryShelter\":\r\n        break;\r\n      case \"PolygonBoundaryShelterZReducer\":\r\n        playerScriptIns._removeCoveringShelterZReducer(other);\r\n        if (0 == playerScriptIns.coveringShelterZReducers.length) {\r\n          setLocalZOrder(self.node, 5);\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  },\r\n\r\n  _generateRandomDirection() {\r\n    return ALL_DISCRETE_DIRECTIONS_CLOCKWISE[Math.floor(Math.random() * ALL_DISCRETE_DIRECTIONS_CLOCKWISE.length)];\r\n  },\r\n\r\n  _generateRandomDirectionExcluding(toExcludeDx, toExcludeDy) {\r\n    let randomDirectionList = [];\r\n    let exactIdx = null;\r\n    for (let ii = 0; ii < ALL_DISCRETE_DIRECTIONS_CLOCKWISE.length; ++ii) {\r\n      if (toExcludeDx != ALL_DISCRETE_DIRECTIONS_CLOCKWISE[ii].dx || toExcludeDy != ALL_DISCRETE_DIRECTIONS_CLOCKWISE[ii].dy) continue;\r\n      exactIdx = ii;\r\n      break;\r\n    }\r\n    if (null == exactIdx) {\r\n      return this._generateRandomDirection();\r\n    }\r\n\r\n    for (let ii = 0; ii < ALL_DISCRETE_DIRECTIONS_CLOCKWISE.length; ++ii) {\r\n      if (ii == exactIdx || ((ii - 1) % ALL_DISCRETE_DIRECTIONS_CLOCKWISE.length) == exactIdx || ((ii + 1) % ALL_DISCRETE_DIRECTIONS_CLOCKWISE.length) == exactIdx) continue;\r\n      randomDirectionList.push(ALL_DISCRETE_DIRECTIONS_CLOCKWISE[ii]);\r\n    }\r\n    return randomDirectionList[Math.floor(Math.random() * randomDirectionList.length)]\r\n  },\r\n\r\n  updateSpeed(proposedSpeed) {\r\n    if (0 == proposedSpeed && 0 < this.speed) {\r\n      this.startFrozenDisplay(); \r\n    } \r\n    if (0 < proposedSpeed && 0 == this.speed) {\r\n      this.stopFrozenDisplay(); \r\n    } \r\n    this.speed = proposedSpeed; \r\n  },\r\n\r\n  startFrozenDisplay() {\r\n    this.node.opacity = 64; \r\n  },\r\n\r\n  stopFrozenDisplay() {\r\n    this.node.opacity = 255; \r\n  },\r\n});\r\n"]}